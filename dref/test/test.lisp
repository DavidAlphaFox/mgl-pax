(in-package :dref-test)

(deftest test-util ()
  (test-has-setf-p))

(deftest test-has-setf-p ()
  (is (null (dref::has-setf-p 'undefined)))
  (is (dref::has-setf-p 'documentation))
  (is (dref::has-setf-p 'has-setf-expander))
  (is (dref::has-setf-p 'has-setf-function))
  (is (dref::has-setf-p 'has-setf-generic-function))
  (is (null (dref::has-setf-p 'defun)))
  (with-failure-expected
      ((and (alexandria:featurep '(:not (:or :ccl :clisp :sbcl)))
            'failure))
    (is (dref::has-setf-p 'full-setf))))


(deftest test-definitions ()
  (check-ref-sets (definitions 'undefined) ())
  (with-failure-expected ((and (alexandria:featurep '(:or :clisp))
                               'failure))
    (check-ref-sets (definitions '*some-var*)
                    `(,(xref '*some-var* 'variable))))
  (with-failure-expected ((and (alexandria:featurep '(:or :clisp))
                               'failure))
    (check-ref-sets (definitions 'my-smac)
                    `(,(xref 'my-smac 'symbol-macro))))
  (check-ref-sets (definitions 'foo2) (list (xref 'foo2 'function)))
  (with-failure-expected ((alexandria:featurep :clisp))
    (check-ref-sets (definitions 'foo) (list (xref 'foo 'function)
                                             (xref 'foo 'class)
                                             (xref 'foo 'compiler-macro)))
    (check-ref-sets (definitions 'dref) (list (dref 'dref 'function)
                                              (dref 'dref 'package)
                                              (xref "dref" 'asdf:system)
                                              (xref 'dref 'class))))
  (with-failure-expected ((alexandria:featurep :abcl))
    (check-ref-sets (definitions "dref")
                    (if (string= (package-name 'dref) "dref")
                        (list (xref "dref" 'package)
                              (xref "dref" 'asdf:system))
                        (list (xref "dref" 'asdf:system))))
    (check-ref-sets (definitions "DREF" :dtype t)
                    (if (string= (package-name 'dref) "DREF")
                        (list (xref "DREF" 'package)
                              (xref "dref" 'asdf:system))
                        (list (xref "dref" 'asdf:system)))))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl :clisp :ecl))
                               'failure))
    (check-ref-sets (definitions 'bar)
                    `(,(xref 'bar 'macro)
                      ,(xref 'bar 'constant)
                      ,(xref 'bar 'type))))
  (with-failure-expected ((and (alexandria:featurep
                                '(:or :abcl :clisp :cmucl :ecl))
                               'failure))
    (check-ref-sets (definitions 'has-setf-expander)
                    `(,(xref 'has-setf-expander 'setf))))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl :clisp))
                               'failure))
    (check-ref-sets (definitions 'test-gf)
                    `(,(xref 'test-gf 'generic-function)
                      ,(xref 'test-gf '(method () (number)))
                      ,(xref 'test-gf '(method () ((eql 7))))
                      ,(xref 'test-gf '(method ()
                                        ((eql #.(find-package :cl))))))))
  (with-failure-expected ((and (alexandria:featurep
                                '(:or :abcl :clisp :cmucl :ecl))
                               'failure))
    (check-ref-sets (definitions 'my-comb)
                    `(,(xref 'my-comb 'method-combination))))
  ;; There _may_ be a GENERIC-FUNCTION and a SETF generic function too.
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl :clisp :ecl))
                               'failure))
    (check-ref-sets (remove-if (lambda (dref)
                                 (member (dref-locative-type dref)
                                         '(generic-function setf)))
                               (definitions 'foo-a))
                    `(,(xref 'foo-a 'variable)
                      ,(xref 'foo-a '(accessor foo))))
    (check-ref-sets (remove 'generic-function (definitions 'foo-r)
                            :key #'dref-locative-type)
                    `(,(xref 'foo-r 'variable)
                      ,(xref 'foo-r '(reader foo))))
    (check-ref-sets (remove 'generic-function (definitions 'foo-w)
                            :key #'dref-locative-type)
                    `(,(xref 'foo-w 'variable)
                      ,(xref 'foo-w '(writer foo)))))
  ;; BAZ-AAA is not recognized as a structure accessor on most Lisps.
  ;; On CCL, (SETF BAZ-AAA) shows up as well. FIXME: Maybe that's how
  ;; it should be?
  (with-failure-expected ((and (alexandria:featurep '(:not (:or :sbcl)))
                               'failure))
    (check-ref-sets (definitions 'baz-aaa)
                    `(,(xref 'baz-aaa '(structure-accessor baz)))))
  (with-failure-expected ((alexandria:featurep '(:not :sbcl)))
    (check-ref-sets (definitions 'dynamic-extent)
                    `(,(xref 'dynamic-extent 'declaration))))
  (with-failure-expected ((alexandria:featurep :clisp))
    (check-ref-sets (definitions 'my-error)
                    `(,(xref 'my-error 'condition)
                      ,(xref 'my-error 'function))))
  (with-failure-expected ((alexandria:featurep '(:not :sbcl)))
    (check-ref-sets (definitions 'test-declaration)
                    `(,(xref 'test-declaration 'declaration))))
  (check-ref-sets (definitions 'xxx-rt)
                  `(,(xref 'xxx-rt 'readtable)))
  (check-ref-sets (definitions 'my-loc)
                  `(,(xref 'my-loc 'locative)))
  #+sbcl
  (check-ref-sets+ (definitions 'print)
                   `(,(xref 'print 'function)
                     ,(xref 'print '(unknown (:defoptimizer print
                                                 sb-c:derive-type)))
                     ,(xref 'print '(unknown (declaim print sb-c:defknown)))))
  ;; This is a primitive object, that (SWANK-BACKEND:FIND-DEFINITIONS
  ;; 'SB-C::CATCH-BLOCK) returns as a TYPE.
  #+sbcl
  (signals-not (locate-error)
    (definitions 'sb-c::catch-block))
  (with-test ("actualized")
    (with-failure-expected ((alexandria:featurep :clisp))
      (check-ref-sets (definitions 'foo :dtype 'type)
                      `(,(xref 'foo 'class)))))
  (with-test ("invalid dtype")
    (signals (error)
      (definitions nil :dtype '"x"))))

(defun check-ref-sets (refs expected-refs)
  (is (match-values (diff-sets (capture refs) (capture expected-refs)
                               :test #'xref=)
        (endp *)
        (endp *))))

(defun check-ref-sets+ (refs expected-refs)
  (is (endp (set-difference (capture expected-refs) (capture refs)
                            :test #'xref=))))

(defun diff-sets (set1 set2 &key (test 'eql))
  (values (set-difference set1 set2 :test test)
          (set-difference set2 set1 :test test)))


(deftest test-dspec ()
  (check-dspec-roundtrip (dref '*some-var* 'variable))
  (check-dspec-roundtrip (dref 'bar 'constant))
  (check-dspec-roundtrip (dref 'bar 'macro))
  (check-dspec-roundtrip (dref 'block 'macro))
  (check-dspec-roundtrip (dref 'foo 'compiler-macro))
  (check-dspec-roundtrip (dref 'my-smac 'symbol-macro))
  (check-dspec-roundtrip (dref 'has-setf-expander 'setf))
  (check-dspec-roundtrip (dref 'has-setf-function 'setf))
  (check-dspec-roundtrip (dref 'foo 'function))
  (check-dspec-roundtrip (dref 'test-gf 'generic-function))
  (with-failure-expected ((alexandria:featurep '(:or :ecl)))
    (check-dspec-roundtrip (dref 'test-gf '(method () ((eql 7)))))
    (check-dspec-roundtrip
     (dref 'test-gf '(method () ((eql #.(find-package :cl)))))))
  (check-dspec-roundtrip (dref 'gf2 '(method (:around) (t))))
  (check-dspec-roundtrip (dref 'gf2 '(method (:after) (t))))
  (check-dspec-roundtrip (dref 'my-comb 'method-combination))
  (check-dspec-roundtrip (dref 'bar 'type))
  (check-dspec-roundtrip (dref 'foo 'class))
  (check-dspec-roundtrip (dref 'array 'class))
  (check-dspec-roundtrip (dref 'my-error 'condition))
  (check-dspec-roundtrip (dref  'dref 'package))
  (let ((dref (dref 'print '(unknown (:define-vop print print)) nil)))
    (when dref
      (check-dspec-roundtrip dref))))

(defun check-dspec-roundtrip (dref &optional (expected-result dref))
  (let* ((dspec (dref::definition-to-dspec dref))
         (roundtripped (dref::dspec-to-definition dspec (dref-name dref))))
    (when (is roundtripped
              :ctx ("DREF = ~S~%DPSEC = ~S" dref dspec))
      (is (xref= (capture roundtripped) (capture expected-result))
          :ctx ("DREF = ~S~%DPSEC = ~S" dref dspec)))))


(deftest test-arglist ()
  (test-macro-arg-names)
  (test-function-arg-names)
  (is (null (arglist (dref 'my-smac 'symbol-macro))))
  (test-arglist/macro)
  (test-arglist/compiler-macro)
  (test-arglist/setf)
  (test-arglist/function)
  (test-arglist/generic-function)
  (test-arglist/method)
  (test-arglist/type)
  (test-arglist/locative)
  (test-arglist/symbol-locative)
  (test-arglist/lambda))

(deftest test-macro-arg-names ()
  (is (equal '(x a b c)
             (dref::macro-arg-names '((&key (x y)) (a b) &key (c d))))))

(deftest test-function-arg-names ()
  (is (equal (dref::function-arg-names '(x &optional (o 1) &key (k 2 kp)))
             '(x o k kp)))
  (is (equal (dref::function-arg-names '(&key ((:xxx xxx))))
             '(xxx)))
  (is (equal (dref::function-arg-names '(&key ((:xxx xxx) nil xxxp)))
             '(xxx xxxp)))
  (is (equal (dref::function-arg-names '(&key ((:xxx xxx) nil xxxp)
                                         &allow-other-keys &aux (a 7)))
             '(xxx xxxp a))))

(deftest test-arglist/macro ()
  (with-failure-expected ((and (alexandria:featurep
                                '(:or :abcl :allegro :clisp))
                               'failure))
    (is (or (equal (% (arglist (dref 'macro-with-fancy-args 'macro)))
                   '(x &optional (o 1) &key (k 2 kp)))
            (equal (arglist (dref 'macro-with-fancy-args 'macro))
                   '(x &optional (o 1) &key (k 2))))))
  (with-test ("special operator")
    (is (match-values (arglist (dref 'function 'macro))
          (null *)
          (not *)))))

(deftest test-arglist/compiler-macro ()
  (with-failure-expected ((and (alexandria:featurep
                                '(:or :abcl :clisp :ecl))
                               'failure))
    (is (match-values (arglist (dref 'cmac 'compiler-macro))
          (equal * '(x &rest y))
          (eq * :macro)))))

(deftest test-arglist/setf ()
  (is (null (arglist (dref 'has-setf-expander 'setf))))
  (is (match-values (arglist (dref 'has-setf-function 'setf))
        (equal * '(v))
        (eq * :ordinary)))
  (is (match-values (arglist (dref 'has-setf-generic-function 'setf))
        (equal * '(v))
        (eq * :ordinary)))
  (is (match-values (arglist (dref 'has-setf-generic-function
                                   '(setf (method () (string)))))
        (equal * '(v))
        (eq * :ordinary))))

(deftest test-arglist/function ()
  (is (match-values (arglist (dref 'function-with-fancy-args 'function))
        (equal * '(x &optional (o 1) &key (k 2 kp)))
        (eq * :ordinary)))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl :clisp :ecl))
                               'failure))
    (is (match-values (arglist (dref 'traced-foo 'function))
          (equal * '(x))
          (eq * :ordinary)))))

(deftest test-arglist/generic-function ()
  (is (match-values (arglist (dref 'test-gf 'generic-function))
        (equal * '(x))
        (eq * :ordinary)))
  (with-failure-expected ((and (alexandria:featurep '(:or :clisp :ecl))
                               'failure))
    (is (match-values (arglist (dref 'traced-gf 'function))
          (equal * '(x))
          (eq * :ordinary)))))

(deftest test-arglist/method ()
  (is (match-values (arglist (dref 'gf2 '(method (:around) (t))))
        (equal * '(x &key))
        (eq * :ordinary)))
  (is (match-values (arglist (dref 'gf2 '(method (:after) (t))))
        (equal * '(x &key y))
        (eq * :ordinary)))
  (is (match-values (arglist (dref 'gf2 '(method () (number))))
        (equal * '(x &key ((:x y) t)))
        (eq * :ordinary))))

(deftest test-arglist/type ()
  (with-failure-expected ((alexandria:featurep '(:or :abcl :allegro :clisp
                                                 :ccl :cmucl :ecl)))
    (is (match-values (arglist (dref 'bar 'type))
          (equal * '(x &rest r))
          (eq * :deftype))))
  (is (listp (arglist (dref 'debug0-non-constant-type 'type)))))

(deftest test-arglist/locative ()
  (is (match-values (arglist (dref 'loc-with-args 'locative))
        (equal * '((x y) &key z))
        (eq * :destructuring))))

(deftest test-arglist/symbol-locative ()
  (is (match-values (arglist (dref 'sloc1 'sloc))
        (equal * '(&key z))
        (eq * :macro))))

(deftest test-arglist/lambda ()
  (is (match-values (arglist (dref nil '(lambda :arglist ((x y) z)
                                         :arglist-type :macro)))
        (equal * '((x y) z))
        (eq * :macro))))


(deftest test-docstring ()
  (is (equal (docstring (xref 'foo-a 'variable))
             "FOO-A variable"))
  (is (equal (docstring (dref 'foo-a 'variable)) "FOO-A variable"))
  (is (equal (docstring (dref 'bar 'constant)) "BAR constant"))
  (is (equal (docstring (dref 'bar 'macro)) "BAR macro"))
  (signals-not (error)
    (docstring (dref 'function 'macro)))
  (is (equal (docstring (dref 'my-smac 'symbol-macro))
             "MY-SMAC symbol-macro"))
  (with-failure-expected ((and (alexandria:featurep
                                '(:or :abcl :allegro :ccl :ecl))
                               'failure))
    (is (equal (docstring (dref 'foo 'compiler-macro))
               "FOO compiler-macro")))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl))
                               'failure))
    (is (equal (docstring (dref 'has-setf-expander 'setf))
               "HAS-SETF-EXPANDER setf"))
    (is (equal (docstring (dref 'has-setf-function 'setf))
               "HAS-SETF-FUNCTION setf")))
  (with-failure-expected ((and (alexandria:featurep '(:or :cmucl))
                               'failure))
    (is (equal (docstring (dref 'has-setf-generic-function 'setf))
               "HAS-SETF-GENERIC-FUNCTION setf")))
  (is (equal (docstring (dref 'has-setf-generic-function
                              '(setf (method () (string)))))
             "HAS-SETF-GENERIC-FUNCTION (setf (method () (string)))"))
  (with-failure-expected ((and (alexandria:featurep '(:or :ecl))
                               'failure))
    (is (equal (docstring (dref 'foo 'function)) "FOO function")))
  (is (equal (docstring (dref 'traced-foo 'function))
             "TRACED-FOO function"))
  (is (equal (docstring (dref 'test-gf 'generic-function))
             "TEST-GF generic-function"))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl :ecl))
                               'failure))
    (is (equal (docstring (dref 'traced-gf 'function))
               "TRACED-GF generic-function")))
  (is (equal (docstring (dref 'test-gf '(method () (number))))
             "TEST-GF (method () (number))"))
  (with-failure-expected ((alexandria:featurep '(:or :abcl :allegro)))
    (is (equal (docstring (dref 'my-comb 'method-combination))
               "MY-COMB method-combination")))
  (is (equal (docstring (dref 'foo-a '(accessor foo)))
             "FOO-A (accessor foo)"))
  (is (equal (docstring (dref 'foo-r '(reader foo)))
             "FOO-R (reader foo)"))
  (is (equal (docstring (dref 'foo-w '(writer foo)))
             "FOO-W (writer foo)"))
  (with-failure-expected ((and (alexandria:featurep '(:or :clisp :ecl))
                               'failure))
    (is (equal (docstring (dref 'baz-aaa '(structure-accessor baz)))
               "BAZ-AAA (structure-accessor baz)")))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl))
                               'failure))
    (is (equal (docstring (dref 'bar 'type))
               "BAR type")))
  (is (equal (docstring (dref 'foo 'class))
             "FOO class"))
  (is (equal (docstring (dref 'my-error 'condition))
             "MY-ERROR condition"))
  (is (null (docstring (dref 'test-declaration 'declaration))))
  (is (null (docstring (dref 'dref 'asdf:system))))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl))
                               'failure))
    (is (equal (docstring (dref 'dref-test 'package))
               "Test package for DRef.")))
  (is (match-values (docstring (dref 'sloc 'locative))
        (equal * "SLOC locative")
        (eq * (find-package :dref-test))))
  (is (match-values (docstring (dref 'sloc1 'sloc))
        (equal * "SLOC1 sloc")
        (eq * (find-package :dref-test))))
  (is (match-values (docstring (dref 'var 'locative))
        (equal * "VAR locative")
        (eq * (find-package :dref-test))))
  (dolist (dref (definitions 'print :dtype 'unknown))
    (is (null (docstring dref))))
  (is (match-values (docstring (dref nil '(lambda :docstring "xxx"
                                           :docstring-package :dref)))
        (equal * "xxx")
        (eq * (find-package :dref)))))


;;;; TEST-SOURCE-LOCATION

(defparameter *source-location-test-cases*
  '(;; DREF::@VARIABLELIKE-LOCATIVES
    (foo-a variable (defvar foo-a))
    (foo-r variable (defvar foo-r))
    (foo-w variable (defvar foo-w))
    (bar constant (defconstant bar))
    ;; DREF::@MACROLIKE-LOCATIVES
    (bar macro (defmacro bar))
    (my-smac symbol-macro (define-symbol-macro my-smac))
    (foo compiler-macro (define-compiler-macro foo))
    (has-setf-expander setf (defsetf has-setf-expander) nil
     ;; No source location for DEFSETF on any implementation.
     t)
    (has-setf-function setf (defun (setf has-setf-function)) nil
     #.(alexandria:featurep '(:or :allegro :cmucl)))
    ;; DREF::@FUNCTIONLIKE-LOCATIVES
    (foo function (defun foo))
    (|Foo| function (defun |Foo|))
    (traced-foo function (defun traced-foo))
    (test-gf generic-function (defgeneric test-gf))
    (test-gf (method () (number)) (defmethod test-gf))
    (my-comb method-combination (define-method-combination my-comb))
    (foo-a (accessor foo) (defclass foo) (a :accessor foo-a))
    (foo-r (reader foo) (defclass foo) (r :reader foo-r))
    (foo-w (writer foo) (defclass foo) (w :writer foo-w))
    (baz-aaa structure-accessor (defstruct baz) nil #+cmucl t)
    ;; DREF::@TYPELIKE-LOCATIVES
    (bar type (deftype bar))
    (foo type (defclass foo))
    (my-error type (define-condition my-error))
    (foo class (defclass foo))
    (test-declaration declaration (define-declaration test-declaration))
    ;; DREF::@CONDITION-SYSTEM-LOCATIVES
    (my-error condition (define-condition my-error))
    (some-restart restart (define-restart some-restart))
    ;; DREF::@PACKAGELIKE-LOCATIVES
    (mgl-pax asdf:system ())
    (mgl-pax package
     (eval-when (:compile-toplevel :load-toplevel :execute))
     (cl:defpackage))
    (xxx-rt readtable (defreadtable xxx-rt))
    ;; DREF-EXT::@ADDING-NEW-LOCATIVES
    (my-loc locative (define-locative-type my-loc))))

(deftest test-source-location ()
  (test-make-source-location)
  (let ((*package* (find-package :dref-test)))
    (dolist (test-case *source-location-test-cases*)
      (apply #'check-source-location test-case)))
  (signals-not (error)
    (source-location (xref 'function 'locative)))
  (with-failure-expected ()
    (signals-not (error)
      (source-location (xref 'locative 'function)))))

(deftest test-make-source-location ()
  (let ((loc (make-source-location :file #P"xxx"
                                   :file-position 7
                                   :buffer "bbb"
                                   :snippet "(defun foo ())")))
    (is (equal (source-location-file loc) "xxx"))
    (is (eql (source-location-file-position loc) 7))
    (is (equal (source-location-buffer loc) "bbb"))
    (is (equal (source-location-buffer-position loc) 8))
    (is (equal (source-location-snippet loc) "(defun foo ())"))))

(defun working-locative-p (locative)
  (let ((type (locative-type locative)))
    (cond ((alexandria:featurep :abcl)
           nil)
          ((alexandria:featurep :clisp)
           nil)
          ((eq type 'symbol-macro)
           (alexandria:featurep '(:not :ccl)))
          ((eq type 'declaration)
           (alexandria:featurep :sbcl))
          ((eq type 'readtable)
           nil)
          ((eq type 'generic-function)
           ;; AllegroCL is off by one form.
           (alexandria:featurep '(:not :allegro)))
          ((eq type 'method-combination)
           (alexandria:featurep '(:not (:or :abcl :cmucl :ecl))))
          ((member type '(reader writer accessor))
           (alexandria:featurep '(:not (:or :abcl :cmucl :ecl))))
          ((eq type 'structure-accessor)
           (alexandria:featurep '(:not (:or :abcl :allegro :ecl))))
          ((eq type 'type)
           (alexandria:featurep '(:not :ecl)))
          ((eq type 'package)
           (alexandria:featurep '(:not (:or :abcl :allegro :clisp :cmucl
                                            :ecl))))
          (t
           t))))

(defun check-source-location (name locative prefix &optional alternative-prefix
                                                     failure-expected-p)
  (let* ((ref (xref name locative))
         (resolved (resolve ref nil)))
    ;; Test SOURCE-LOCATION with a REFERENCE and a resolved object if
    ;; there is one.
    (dolist (target (if resolved
                        (list ref resolved)
                        (list ref)))
      (with-test ((format nil "navigate to ~S" target))
        (with-failure-expected ((or (not (working-locative-p locative))
                                    failure-expected-p))
          (signals-not (error :msg (format nil "SOURCE-LOCATION ~S runs"
                                           target))
            (let ((location (source-location target)))
              (when (is (and (% location) (not (eq :error (first location))))
                        :msg `("Find source location for (~S ~S)."
                               ,name ,locative))
                (multiple-value-bind (file position)
                    (extract-source-location location)
                  (when (is file)
                    (let ((content (if (stringp prefix)
                                       (read-string-from-file-position
                                        file (or position 0)
                                        (max (length prefix)
                                             (length alternative-prefix)))
                                       (read-form-from-file-position
                                        file (or position 0)))))
                      (is (and (eq (not (listp prefix))
                                   (not (listp content)))
                               (or (alexandria:starts-with-subseq
                                    prefix content :test #'equal)
                                   (and alternative-prefix
                                        (alexandria:starts-with-subseq
                                         alternative-prefix content
                                         :test #'equal))))
                          :msg `("Find prefix ~S~@[ or ~S~] ~
                                    at source location~%~S~% ~
                                    for reference (~S ~S).~%~
                                    Form found was:~%~S."
                                 ,prefix ,alternative-prefix
                                 ,location ,name ,locative
                                 ,content)))))))))))))

(defun extract-source-location (location)
  (values (source-location-file location)
          (source-location-file-position location)))

(defun read-string-from-file-position (filename position n)
  (with-open-file (stream filename
                          :direction :input
                          :external-format dref::*utf-8-external-format*)
    (file-position stream position)
    (let ((string (make-string n)))
      (read-sequence string stream)
      string)))

(defun read-form-from-file-position (filename position)
  (with-open-file (stream filename
                          :direction :input
                          :external-format dref::*utf-8-external-format*)
    (file-position stream position)
    (read stream)))


(deftest test-locative-type-hierarchy ()
  (test-lisp-locative-type-hierarchy)
  (test-pseudo-locative-type-hierarchy))

(deftest test-lisp-locative-type-hierarchy ()
  (signals-not (error)
    (dref::check-locative-type-hierarchy nil 'classless ()))
  (signals-not (error)
    (dref::check-locative-type-hierarchy nil 'classless '(package-dref)))
  (signals (error :pred "DREF-EXT:DEFINE-LOCATIVE-TYPE of READTABLE with superclasses (DREF-EXT:PACKAGE-DREF) contradicts the Lisp class hierarchy where READTABLE is not a subclass of PACKAGE, whose DRef class is DREF-EXT:PACKAGE-DREF.")
    (dref::check-locative-type-hierarchy nil 'readtable '(package-dref)))
  (signals-not (error)
    (dref::check-locative-type-hierarchy nil 'subclass '(class-dref)))
  (signals (error :pred "DREF-EXT:DEFINE-LOCATIVE-TYPE of DREF-TEST::SUBCLASS with superclasses NIL contradicts the Lisp class hierarchy where DREF-TEST::SUBCLASS is a subclass of CLASS, whose DRef class is DREF-EXT:CLASS-DREF, but none of the superclasses is a subclass of DREF-EXT:CLASS-DREF.")
    (dref::check-locative-type-hierarchy nil 'subclass '()))
  (signals (error :pred "DREF-EXT:DEFINE-LOCATIVE-TYPE of DREF-TEST::JUNK with superclasses (DREF-EXT:LAMBDA-DREF) is illegal because DREF-EXT:LAMBDA-DREF is the DREF-EXT:DREF-CLASS of LAMBDA, one of DREF:PSEUDO-LOCATIVE-TYPES.")
    (dref::check-locative-type-hierarchy nil 'junk '(lambda-dref))))

(deftest test-pseudo-locative-type-hierarchy ()
  (signals-not (error)
    (dref::check-locative-type-hierarchy t 'classless ()))
  (signals (error :pred "DREF-EXT:DEFINE-PSEUDO-LOCATIVE-TYPE of NUMBER is illegal because NUMBER names a class.")
    (dref::check-locative-type-hierarchy t 'number ()))
  (signals (error :pred "DREF-EXT:DEFINE-PSEUDO-LOCATIVE-TYPE of DREF-TEST::CLASSLESS with superclasses (DREF-EXT:PACKAGE-DREF) is illegal because DREF-EXT:PACKAGE-DREF is the DREF-EXT:DREF-CLASS of PACKAGE, one of DREF:LISP-LOCATIVE-TYPES.")
    (dref::check-locative-type-hierarchy t 'classless '(package-dref))))


(deftest test-dtypes ()
  (test-widest-subtype-of-locative-type)
  (test-narrowest-supertype-of-locative-type)
  (test-dtypep)
  (test-cover-dtype))

(deftest test-widest-subtype-of-locative-type ()
  (is (eq (dref::widest-subtype-of-locative-type 'reader) nil))
  (is (eq (dref::widest-subtype-of-locative-type 'writer) nil))
  (is (eq (dref::widest-subtype-of-locative-type 'accessor) nil))
  (is (eq (dref::widest-subtype-of-locative-type 'method) 'method))
  (is (set-equal-p (dref::widest-subtype-of-locative-type 'type)
                   '(or condition class))))

(deftest test-narrowest-supertype-of-locative-type ()
  (is (eq (dref::narrowest-supertype-of-locative-type 'reader) 'method))
  (is (eq (dref::narrowest-supertype-of-locative-type 'writer) 'method))
  (is (eq (dref::narrowest-supertype-of-locative-type 'accessor) 'method))
  (is (eq (dref::narrowest-supertype-of-locative-type 'method) 'method))
  (is (eq (dref::narrowest-supertype-of-locative-type 'type) t)))


(deftest test-dtypep ()
  (test-dtypep/typep-consistency)
  (test-dtypep/locative-type)
  (test-dtypep/derived)
  (test-dtypep/with-locative-args)
  (test-dtypep/pseudo)
  (test-dtypep/member)
  (test-dtypep/satisfies)
  (test-dtypep/xref))

(deftest test-dtypep/typep-consistency ()
  (let ((objects (list nil t (find-class 'xref) 7 7.1 1/2))
        (types '(nil t xref subclass standard-object number integer
                 (or number class) (and number integer) (not number))))
    (dolist (object objects)
      (dolist (type types)
        (is (eq (typep (% object) (% type)) (dtypep object type)))))))

(deftest test-dtypep/locative-type ()
  (is (not (dref::valid-type-specifier-p 'type)))
  (is (dtypep (find-class 'xref) 'type))
  (is (dtypep (dref 'xref 'class) 'type))
  (is (not (dtypep 7 'type)))
  (is (not (dtypep (dref 'print 'function) 'type))))

(deftest test-dtypep/derived ()
  (is (not (dtypep (find-class 'xref) '(and type condition))))
  (is (not (dtypep (dref 'xref 'class) '(and type condition))))
  (is (dtypep (dref 'foo-a '(accessor foo)) '(and reader writer)))
  (is (not (dtypep (dref 'foo-r '(reader foo)) '(and reader writer))))
  (is (not (dtypep (dref 'foo-w '(writer foo)) '(and reader writer))))
  (is (dtypep (dref 'foo-r '(reader foo)) '(or number reader)))
  (is (not (dtypep (dref 'foo-r '(reader foo)) '(or number accessor))))
  (is (dtypep #'print '(not type)))
  (is (not (dtypep (find-class 'xref) '(not type))))
  (is (dtypep (dref 'bar 'type) '(and type (not class)))))

(deftest test-dtypep/with-locative-args ()
  (is (dtypep (dref 'test-gf '(method () (number))) '(method () (number))))
  (signals (error :pred "Bad arguments")
    (dtypep (dref 'test-gf '(method () (number))) '(method x)))
  (is (xref= (dref 'foo-r '(method () (foo)))
             (xref 'foo-r '(reader foo))))
  (test-dtypep/with-locative-args/actualized))

(deftest test-dtypep/with-locative-args/actualized ()
  (is (dtypep (dref 'foo-r '(method () (foo))) '(method () (foo)))))

(deftest test-dtypep/pseudo ()
  (is (not (dtypep (dref nil 'lambda) t)))
  (is (dtypep (dref nil 'lambda) 'top))
  (is (dtypep (dref nil 'lambda) 'pseudo)))

(deftest test-dtypep/member ()
  (is (not (dref::dtypep 1 '(member))))
  (is (dref::dtypep 1 '(member 1)))
  (is (dref::dtypep 1 '(member 0 1)))
  (is (not (dref::dtypep 1 `(member ,(xref '*print-length* 'variable)))))
  (let ((xref (xref 'number 'class)))
    (is (not (dref::dtypep xref `(member ,xref))))))

(deftest test-dtypep/satisfies ()
  (signals (error)
    (dref::dtypep 1 '(satisfies junk)))
  (signals (error)
    (dref::dtypep 1 '(satisfies)))
  (signals (error)
    (dref::dtypep 1 '(satisfies x y)))
  (signals (error)
    (dref::dtypep 1 '(satisfies "xv")))
  (is (dref::dtypep 1 '(satisfies oddp)))
  (is (not (dref::dtypep 2 '(satisfies oddp))))
  (is (not (dref::dtypep 2 '(satisfies locative-dref-p))))
  (is (not (dref::dtypep (dref 'class 'locative)
                         '(satisfies locative-dref-p))))
  (is (not (dref::dtypep (dref '*print-length* 'variable)
                         '(satisfies locative-dref-p)))))

(defun locative-dref-p (obj)
  (and (typep obj 'dref)
       (eq (dref-locative-type obj) 'locative)))

(deftest test-dtypep/xref ()
  (is (not (dtypep (xref 'number 'junk) 'standard-object))))


(deftest test-cover-dtype ()
  (test-cover-dtype/single)
  (test-support-dtype/single)
  (test-cover-dtype/or)
  (test-cover-dtype/and)
  (test-cover-dtype/not)
  (test-cover-dtype/complex)
  (test-cover-dtype/compound))

(defun set-equal-p (set1 set2)
  (and (endp (capture (set-difference set1 set2)))
       (endp (capture (set-difference set2 set1)))))

(defparameter *std-locative-types*
  '(unknown locative readtable package asdf:system
    declaration condition class type structure-accessor writer
    reader accessor method-combination method generic-function
    function setf compiler-macro symbol-macro macro
    constant variable restart))

(deftest test-cover-dtype/single ()
  (is (eq (dref::cover-dtype/single nil) nil))
  (is (eq (dref::cover-dtype/single 'class) 'class))
  (is (eq (dref::cover-dtype/single 'type) 'type))
  (is (eq (dref::cover-dtype/single 'subclass) 'class))
  ;; There are no NUMBERs with definitions, but
  ;; DREF::COVER-DTYPE/SINGLE doesn't now that.
  (is (eq (dref::cover-dtype/single 'number) t)))

(deftest test-support-dtype/single ()
  (is (eq (dref::support-dtype/single nil) nil))
  (is (eq (dref::support-dtype/single 'class) 'class))
  (is (eq (dref::support-dtype/single 'type) 'type))
  (is (eq (dref::support-dtype/single 'subclass) nil))
  (is (eq (dref::support-dtype/single 'number) nil)))

(deftest test-cover-dtype/or ()
  (is (set-equal-p (dref::cover-dtype '(or)) '()))
  (is (set-equal-p (dref::cover-dtype '(or nil)) '()))
  (is (set-equal-p (dref::cover-dtype '(or pseudo)) (pseudo-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(or t)) (lisp-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(or top)) (locative-types)))
  (signals (error :pred "Invalid")
    (is (set-equal-p (dref::cover-dtype '(or junk)) '())))
  (is (set-equal-p (dref::cover-dtype '(or class)) '(class)))
  (is (set-equal-p (dref::cover-dtype '(or number)) (lisp-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(or number class))
                   (lisp-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(or subclass)) '(class)))
  (is (set-equal-p (dref::cover-dtype '(or subclass class)) '(class)))
  (is (set-equal-p (dref::cover-dtype '(or reader)) '(reader accessor)))
  (is (set-equal-p (dref::cover-dtype '(or reader writer))
                   '(reader writer accessor)))
  (is (set-equal-p (dref::cover-dtype '(or reader (or writer)))
                   '(reader writer accessor)))
  (is (set-equal-p (dref::cover-dtype '(or method))
                   '(method reader writer accessor)))
  (is (set-equal-p (dref::cover-dtype '(or method accessor))
                   '(method reader writer accessor))))

(deftest test-cover-dtype/and ()
  (is (set-equal-p (dref::cover-dtype '(and)) (locative-types)))
  (is (set-equal-p (dref::cover-dtype '(and nil)) '()))
  (is (set-equal-p (dref::cover-dtype '(and pseudo)) (pseudo-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(and t)) (lisp-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(and top)) (locative-types)))
  (signals (error :pred "Invalid")
    (is (set-equal-p (dref::cover-dtype '(and junk)) '())))
  (is (set-equal-p (dref::cover-dtype '(and class)) '(class)))
  (is (set-equal-p (dref::cover-dtype '(and number)) (lisp-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(and number class)) '(class)))
  (is (set-equal-p (dref::cover-dtype '(and subclass)) '(class)))
  (is (set-equal-p (dref::cover-dtype '(and subclass class)) '(class)))
  (is (set-equal-p (dref::cover-dtype '(and reader)) '(reader accessor)))
  (is (set-equal-p (dref::cover-dtype '(and reader writer)) '(accessor)))
  (is (set-equal-p (dref::cover-dtype '(and reader (and writer))) '(accessor)))
  (is (set-equal-p (dref::cover-dtype '(and method))
                   '(method reader writer accessor)))
  (is (set-equal-p (dref::cover-dtype '(and method accessor)) '(accessor))))

(deftest test-cover-dtype/not ()
  (signals (error :pred "Invalid type specifier")
    (dref::cover-dtype '(not)))
  (signals (error :pred "Invalid type specifier")
    (dref::cover-dtype '(not t nil)))
  (is (set-equal-p (dref::cover-dtype '(not nil)) (locative-types)))
  (is (set-equal-p (dref::cover-dtype '(not t)) (pseudo-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(not class))
                   (set-difference (locative-types)
                                   (dref::locative-subtypes 'class)))))

(deftest test-cover-dtype/complex ()
  (is (set-equal-p (dref::cover-dtype '(and nil (or reader writer))) '()))
  (is (set-equal-p (dref::cover-dtype '(and t (or reader writer)))
                   '(reader writer accessor)))
  (is (set-equal-p (dref::cover-dtype '(and reader (or writer accessor)))
                   '(accessor)))
  (is (set-equal-p (dref::cover-dtype '(not (and class)))
                   (set-difference (locative-types)
                                   (dref::locative-subtypes 'class))))
  (is (set-equal-p (dref::cover-dtype '(not (and subclass))) (locative-types)))
  (is (set-equal-p (dref::cover-dtype '(not (or class)))
                   (set-difference (locative-types)
                                   (dref::locative-subtypes 'class))))
  (is (set-equal-p (dref::cover-dtype '(not (or subclass))) (locative-types))))

(deftest test-cover-dtype/compound ()
  (signals-not (error)
    (is (set-equal-p (dref::cover-dtype '(integer 3 5))
                     (lisp-locative-types))))
  (is (set-equal-p (dref::cover-dtype '(member)) ()))
  (is (set-equal-p (dref::cover-dtype `(member ,#'print))
                   '(function)))
  (is (set-equal-p (dref::cover-dtype `(member junk)) '()))
  (is (set-equal-p (dref::cover-dtype `(member 3)) '()))
  (is (set-equal-p (dref::cover-dtype `(member ,#'print junk)) '(function)))
  (is (set-equal-p (dref::cover-dtype `(member ,#'print ,(find-class 'number)))
                   '(function class)))
  (is (set-equal-p (dref::cover-dtype '(satisfies oddp)) (locative-types)))
  (signals (error #+sbcl :pred #+sbcl "to satisfy lambda list")
    (dref::cover-dtype 'bar))
  (signals (error #+sbcl :pred #+sbcl "to satisfy lambda list")
    (dref::cover-dtype `(bar)))
  (is (set-equal-p (dref::cover-dtype '(method () (number)))
                   '(method reader writer accessor))))


;;;; TEST-APROPOS

(defun mgl-pax::%test9jwern% ())
(defun %test9jwern% ())

(deftest test-apropos ()
  (with-failure-expected ((alexandria:featurep '(:or :abcl :clisp)))
    (with-test ("NAME is NIL")
      (check-ref-sets (dref-apropos nil :package :dref-test :external-only t)
                      `(,(xref 'test 'function)
                        ,(xref 'check-ref 'function)
                        ,(xref 'check-ref-sets 'function)
                        ,(xref 'check-source-location 'function)))
      (with-failure-expected ((alexandria:featurep '(:or :cmucl)))
        (signals-not (serious-condition)
          (is (null (find-if (lambda (dref)
                               (stringp (dref-name dref)))
                             (dref-apropos nil
                                           :package (find-package :dref))))))))
    (with-test ("NAME is a SYMBOL")
      (with-test ("PACKAGE is a symbol")
        (check-ref-sets (dref-apropos '%test9jwern% :package :mgl-pax)
                        `(,(xref 'mgl-pax::%test9jwern% 'function))))
      (with-test ("PACKAGE is a symbol matching a nickname")
        (check-ref-sets (dref-apropos '%test9jwern% :package :pax)
                        `(,(xref 'mgl-pax::%test9jwern% 'function))))
      (with-test ("NAME is a lower-case symbol")
        (check-ref-sets (dref-apropos '#:|%test9jwern%| :package :dref-test)
                        `(,(xref '%test9jwern% 'function)))))
    (with-test ("NAME is STRING")
      (with-test ("full match")
        (check-ref-sets (dref-apropos "test" :package :dref-test
                                             :external-only t)
                        `(,(xref 'dref-test:test 'function))))
      (with-test ("partial match")
        (check-ref-sets (dref-apropos "es" :package :dref-test
                                           :external-only t)
                        `(,(xref 'dref-test:test 'function))))
      (with-test ("case-sensitive")
        (with-test ("no match")
          (check-ref-sets (dref-apropos "es" :package :dref-test
                                             :external-only t
                                             :case-sensitive t)
                          ()))
        (with-test ("match")
          (check-ref-sets (dref-apropos "ES" :package :dref-test
                                             :external-only t
                                             :case-sensitive t)
                          `(,(xref 'dref-test:test 'function))))))
    (with-test ("PACKAGE is NIL")
      (check-ref-sets (dref-apropos '%test9jwern%)
                      `(,(xref 'dref-test::%test9jwern% 'function)
                        ,(xref 'mgl-pax::%test9jwern% 'function))))
    (with-test ("PACKAGE is STRING")
      (with-test ("full match")
        (check-ref-sets (dref-apropos '%test9jwern% :package "dref-test")
                        `(,(xref 'dref-test::%test9jwern% 'function))))
      (with-test ("partial match")
        (check-ref-sets (dref-apropos '%test9jwern% :package "dref")
                        `(,(xref 'dref-test::%test9jwern% 'function))))
      (with-test ("case-sensitive")
        (with-test ("no match")
          (check-ref-sets (dref-apropos '%test9jwern% :package "dref"
                                                      :case-sensitive t)
                          ()))
        (with-test ("match")
          (check-ref-sets (dref-apropos '%test9jwern% :package "DREF"
                                                      :case-sensitive t)
                          `(,(xref 'dref-test::%test9jwern%
                                   'function))))))
    (with-test ("PACKAGE is :ANY")
      (is (null (dref-apropos nil :package :any :dtype 'asdf:system)))
      (is (not (null (dref-apropos 'foo2 :package :any :dtype 'function)))))
    (with-test ("PACKAGE is :NONE")
      (check-ref-sets (dref-apropos "dref" :package :none)
                      `(,(xref (package-name :dref) 'package)
                        ,(xref (package-name :dref-ext) 'package)
                        ,(xref (package-name :dref-test) 'package)
                        ,(xref "dref" 'asdf:system)
                        ,(xref "dref/full" 'asdf:system)
                        ,(xref "dref-test" 'asdf:system)
                        ,(xref "dref-test/autoload" 'asdf:system)))))
  (with-test ("LOCATIVE-TYPES")
    (with-test ("only asdf systems")
      (is (= (length (dref-apropos nil :dtype 'asdf:system))
             (length (asdf:registered-systems)))))
    (with-test ("only packages")
      (is (= (length (dref-apropos nil :dtype 'package))
             (length (list-all-packages)))))
    ;; ABCL bundles an older named-readtables version, and somehow
    ;; named-readtables/doc and named-readtables/test can get loaded.
    (with-failure-expected ((alexandria:featurep :abcl))
      (with-test ("asdf systems and packages")
        (is (= (length (dref-apropos nil :dtype '(or asdf:system package)))
               (+ (length (asdf:registered-systems))
                  (length (list-all-packages)))))))
    #+sbcl
    (when (dref 'pax:clhs 'locative nil)
      (with-test ("PSEUDO")
        (is (plusp (length (% (dref-apropos 'print :dtype 'pseudo)))))))
    #+sbcl
    (with-test ("ALL")
      (is (= (+ (length (% (dref-apropos 'print :dtype t)))
                (length (% (dref-apropos 'print :dtype 'pseudo))))
             (length (% (dref-apropos 'print :dtype 'top)))))))
  (with-failure-expected ((alexandria:featurep :clisp))
    (with-test ("actualized")
      (check-ref-sets (dref-apropos 'foo :dtype 'type :package '#:dref-test)
                      `(,(xref 'foo 'class)))
      (check-ref-sets (dref-apropos 'my-error :dtype 'type
                                              :package '#:dref-test)
                      `(,(xref 'my-error 'condition)))
      (check-ref-sets (dref-apropos 'my-error :dtype 'class
                                              :package '#:dref-test)
                      `(,(xref 'my-error 'condition)))))
  (with-test ("invalid dtype")
    (signals (error)
      (dref-apropos nil :dtype '"x"))
    (signals (error)
      (dref-apropos nil :package :none :dtype '"x")))
  (with-failure-expected ((alexandria:featurep '(:or :abcl :clisp)))
    (is (= (length (dref-apropos 'test-gf :package 'dref-test :dtype 'method))
           3))
    (check-ref-sets (dref-apropos 'test-gf :package 'dref-test
                                           :dtype '(method () (number)))
                    `(,(xref 'test-gf '(method () (number)))))))


(deftest test-all ()
  (test-util)
  (test-locate)
  (test-definitions)
  (test-dspec)
  (test-arglist)
  (test-docstring)
  (test-source-location)
  (test-locative-type-hierarchy)
  (test-dtypes)
  (test-apropos))

(defun test (&key (debug nil) (print 'unexpected) (describe *describe*))
  ;; Bind *PACKAGE* so that names of tests printed have package names,
  ;; and M-. works on them in Slime.
  (handler-bind ((warning (lambda (c)
                            (unless (expected-style-warning-p c)
                              (muffle-warning)))))
    (with-compilation-unit (:override t)
      (let ((*package* (find-package :common-lisp))
            (*print-duration* nil)
            (*print-compactly* t)
            (*defer-describe* t))
        (warn-on-tests-not-run ((find-package :dref-test))
          (print (try 'test-all :debug debug :print print
                                :describe describe)))))))

(defun expected-style-warning-p (c)
  (search "junk" (princ-to-string c)))

#+nil
(test)

#+nil
(test-all)
