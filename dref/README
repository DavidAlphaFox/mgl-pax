# DRef Manual

###### \[in package DREF\]
## Introduction

*What if definitions were first-class objects?*

Some defining forms do not create first-class
objects. For example, DEFUN creates
FUNCTION objects, but DEFVAR does not create variable
objects as no such thing exists. The main purpose of this library is
to fill this gap with the introduction of XREF objects:

```common-lisp
(xref '*my-var* 'variable)
==> #<XREF *MY-VAR* VARIABLE>
```

XREFs just package up a @NAME (`*MY-VAR*`) and a
@LOCATIVE (VARIABLE). They need not denote existing
definitions until we actually want to use them:

```
(docstring (xref '*my-var* 'variable))
.. debugger invoked on LOCATE-ERROR:
..   Could not locate *MY-VAR* VARIABLE.
```

```common-lisp
(defvar *my-var* nil
  "This is my var.")

(docstring (xref '*my-var* 'variable))
=> "This is my var."
```

Behind the scenes, the DOCSTRING function LOCATEs the definition
corresponding to its XREF argument, turning it into a DREF:

```common-lisp
(locate (xref '*my-var* 'variable))
==> #<DREF *MY-VAR* VARIABLE>
```

Within DRef, the DREF-EXT::@DREF-SUBCLASSES form the basis of
extending DOCSTRING, SOURCE-LOCATION and ARGLIST. Outside DRef,
PAX makes PAX:DOCUMENT extensible through
PAX:DOCUMENT-OBJECT\*, which has methods specialized on DREFs.

Finally, existing definitions can be queried with DEFINITIONS and
DREF-APROPOS:

```
(definitions 'dref-ext:locate*)
==> (#<DREF LOCATE* GENERIC-FUNCTION>
-->  #<DREF LOCATE* (METHOD NIL (GLOSSARY-TERM))>
-->  #<DREF LOCATE* (METHOD NIL (SECTION))>
-->  #<DREF LOCATE* (METHOD NIL (READTABLE))>
-->  #<DREF LOCATE* (METHOD NIL (PACKAGE))>
-->  #<DREF LOCATE* (METHOD NIL (ASDF/SYSTEM:SYSTEM))>
-->  #<DREF LOCATE* (METHOD NIL (CLASS))>
-->  #<DREF LOCATE* (METHOD NIL (METHOD))>
-->  #<DREF LOCATE* (METHOD NIL (GENERIC-FUNCTION))>
-->  #<DREF LOCATE* (METHOD NIL (FUNCTION))>
-->  #<DREF LOCATE* (METHOD (:AROUND) (T))>
-->  #<DREF LOCATE* (METHOD NIL (T))> #<DREF LOCATE* (METHOD NIL (XREF))>
-->  #<DREF LOCATE* (METHOD NIL (DREF))>)
```

```common-lisp
(dref-apropos 'locate-error :package :dref :external-only t)
==> (#<DREF LOCATE-ERROR CONDITION> #<DREF LOCATE-ERROR FUNCTION>)

(dref-apropos "ate-err" :package :dref :external-only t)
==> (#<DREF LOCATE-ERROR CONDITION> #<DREF LOCATE-ERROR FUNCTION>)
```


## Locatives and References

After the @INTRODUCTION, here we get into the details. Of special
interest are:

- The XREF function to construct an arbitrary @REFERENCE without any
  checking of validity.

- LOCATE and DREF to construct a syntactically valid
  reference (matching the LAMBDA-LIST in the locative type's
  definition) that refers to an exisiting
  definition.

- RESOLVE to find the first-class (non-XREF) object the
  definition refers to, if any.

@OPERATIONS (ARGLIST, DOCSTRING, SOURCE-LOCATION) know how to deal
with references (discussed in the DREF-EXT::@EXTENDING-DREF).

- [class] XREF

    An XREF (cross-reference) may represent some
    kind of definition of its @NAME in the context given by its
    @LOCATIVE. The definition may not exist and the locative may be
    malformed. The subclass DREF
    represents definitions that exist.

- [class] DREF XREF

    DREFs can be thought of as referring to definitions
    that actually exist, although changes in the system can invalidate
    them (for example, a DREF to a function definition can be
    invalidated by FMAKUNBOUND).
    
    DREFs must be created with LOCATE, and their purpose is to allow
    easy specialization of other generic functions (see
    DREF-EXT::@EXTENDING-DREF) and to confine locative validation to
    LOCATE.

- [function] XREF NAME LOCATIVE

    A shorthand for `(MAKE-INSTANCE 'XREF :NAME NAME :LOCATIVE LOCATIVE)`.
    It does no error checking: the LOCATIVE-TYPE of LOCATIVE-TYPE need
    not be defined, and the LOCATIVE-ARGS need not be valid. Use LOCATE
    or the DREF function to create DREF objects.

- [function] XREF= XREF1 XREF2

    See if XREF1 and XREF2 have the same XREF-NAME and XREF-LOCATIVE
    under EQUAL. Comparing like this makes most sense for
    DREFs. However, two XREFs different under XREF=
    may denote the same DREFs.

- [function] LOCATE OBJECT &OPTIONAL (ERRORP T)

    Return a DREF representing the definition given by the arguments.
    In the same dynamic environment, two DREFs denote the same
    thing if and only if they are XREF=.
    
    OBJECT must be a supported first-class object, a DREF, or an
    XREF:
    
    ```common-lisp
    (locate #'print)
    ==> #<DREF PRINT FUNCTION>
    ```
    
    ```common-lisp
    (locate (locate #'print))
    ==> #<DREF PRINT FUNCTION>
    ```
    
    ```common-lisp
    (locate (xref 'print 'function))
    ==> #<DREF PRINT FUNCTION>
    ```
    
    LOCATE-ERROR is signalled if OBJECT is an XREF with malformed
    LOCATIVE-ARGS, or if no corresponding definition is found. If ERRORP
    is NIL, then NIL and the LOCATE-ERROR condition are returned
    instead.
    
    ```common-lisp
    (locate (xref 'no-such-function 'function))
    .. debugger invoked on LOCATE-ERROR:
    ..   Could not locate NO-SUCH-FUNCTION FUNCTION.
    ..   NO-SUCH-FUNCTION is not a symbol naming a function.
    ```
    
    ```common-lisp
    (locate (xref 'print '(function xxx)))
    .. debugger invoked on LOCATE-ERROR:
    ..   Could not locate PRINT #'XXX.
    ..   Bad arguments (XXX) for locative FUNCTION with lambda list NIL.
    ```
    
    ```common-lisp
    (locate "xxx")
    .. debugger invoked on LOCATE-ERROR:
    ..   Could not locate "xxx".
    ```
    
    Use the low-level XREF to construct an XREF without error
    checking.
    
    Can be extended via LOCATE\*.

- [function] DREF NAME LOCATIVE &OPTIONAL (ERRORP T)

    Shorthand for `(LOCATE (XREF NAME LOCATIVE) ERRORP)`.

- [function] RESOLVE OBJECT &OPTIONAL (ERRORP T)

    If OBJECT is an XREF, then return the first-class object
    associated with its definition if any. Return OBJECT if it's not an
    XREF. Thus, the value returned is never an XREF.
    
    ```common-lisp
    (resolve (dref 'print 'function))
    ==> #<FUNCTION PRINT>
    ```
    
    ```common-lisp
    (resolve #'print)
    ==> #<FUNCTION PRINT>
    ```
    
    If OBJECT is an XREF, and the definition for it cannot be LOCATEd,
    then signal a LOCATE-ERROR condition.
    
    ```common-lisp
    (resolve (xref 'undefined 'variable))
    .. debugger invoked on LOCATE-ERROR:
    ..   Could not locate UNDEFINED VARIABLE.
    ```
    
    If there is a definition, but there is no first-class object
    corresponding to it, then signal a RESOLVE-ERROR condition or return
    NIL depending on ERRORP:
    
    ```common-lisp
    (resolve (dref '*print-length* 'variable))
    .. debugger invoked on RESOLVE-ERROR:
    ..   Could not resolve *PRINT-LENGTH* VARIABLE.
    ```
    
    ```common-lisp
    (resolve (dref '*print-length* 'variable) nil)
    => NIL
    ```
    
    RESOLVE is a partial inverse of LOCATE: if a DREF is
    RESOLVEable, then LOCATEing the object it resolves to recovers the
    DREF equivalent to the original (XREF= and of the same type but not
    EQ).
    
    Can be extended via RESOLVE\*.

- [condition] LOCATE-ERROR ERROR

    Signalled by LOCATE when the definition cannot be
    found, and ERRORP is true.

- [condition] RESOLVE-ERROR ERROR

    Signalled by RESOLVE when the object defined cannot
    be returned, and ERRORP is true.

## DTYPEs

DTYPEs are a generalization Lisp types, to support definitions
without first-class objects. A DTYPE is either

- a normal Lisp type such as `METHOD`,
  `(integer 3 5)`, NIL and T, or

- a @LOCATIVE-TYPE such as TYPE and CLHS, or

- a full @LOCATIVE such as `(METHOD () (NUMBER))` and `(CLHS
  SECTION)`, or

- named with DEFINE-DTYPE, or

- a combination of the previous with AND, OR and
  NOT.

Just as @LOCATIVE-TYPEs extend the Lisp CLASS hierarchy, DTYPEs
extend the Lisp type hierarchy. DTYPEs are used in DEFINITIONS and
DREF-APROPOS to filter the set of definitions as in

```common-lisp
(definitions 'print :dtype '(not unknown))
==> (#<DREF PRINT (CLHS FUNCTION)> #<DREF PRINT FUNCTION>)
```

```common-lisp
(dref-apropos "type specifier" :dtype 'pseudo)
==> (#<DREF "1.4.4.6" #1=(CLHS SECTION)> #<DREF "1.4.4.6.1" #1#>
-->  #<DREF "1.4.4.6.2" #1#> #<DREF "1.4.4.6.3" #1#>
-->  #<DREF "1.4.4.6.4" #1#> #<DREF "4.2.3" #1#>
-->  #<DREF "atomic type specifier" #2=(CLHS GLOSSARY-TERM)>
-->  #<DREF "compound type specifier" #2#>
-->  #<DREF "derived type specifier" #2#> #<DREF "type specifier" #2#>)
```


- [macro] DEFINE-DTYPE NAME LAMBDA-LIST &BODY BODY

    Like DEFTYPE, but it may expand into other DTYPEs.
    
    The following example defines `METHOD*` as the locative METHOD
    without its direct locative subtypes.
    
    ```common-lisp
    (define-dtype method* () '(and method (not reader) (not writer)))
    ```
    
    See DTYPEP for the semantics and also the locative DTYPE.

- [dtype] TOP

    This is the top of the DTYPE hierarchy, much like T for Lisp types.
    It expands to (OR T PSEUDO). While T matches every normal
    Lisp object and objectless definitions present in the running
    Lisp (see LISP-LOCATIVE-TYPES), TOP matches even pseudo
    definitions (see PSEUDO-LOCATIVE-TYPES).

- [dtype] PSEUDO

    This is the union of all PSEUDO-LOCATIVE-TYPES. It expands
    to `(OR ,@(PSEUDO-LOCATIVE-TYPES))`.

- [function] DTYPEP OBJECT DTYPE

    Like CL:TYPEP, but OBJECT may be an XREF and DTYPE may involve
    @LOCATIVE-TYPEs and full @LOCATIVEs.
    
    - OBJECT may be an XREF (including DREFs). `(DTYPEP OBJECT DTYPE)`
      is equivalent to `(DTYPEP (LOCATE OBJECT) DTYPE)`. This form is
      necesary when the definition has no first-class object associated
      with it:
    
        ```common-lisp
        (dtypep (dref 'pi 'constant) 'variable)
        => T
        ```
    
        Note however that as a consequence, DTYPEP deviates from TYPEP
        when OBJECT is an XREF:
    
        ```common-lisp
        (typep (dref 'number 'class) 'class)
        => NIL
        (dtypep (dref 'number 'class) 'class)
        => T
        (typep (xref 'number 'junk) 'standard-object)
        => T
        (dtypep (xref 'number 'junk) 'standard-object)
        => NIL
        (dtypep (xref 'number 'junk) 'junk)
        => NIL
        ```
    
        MEMBER and SATISFIES are only matched with the
        RESOLVEd OBJECT if any:
    
        ```common-lisp
        (let ((dref (dref nil 'type)))
          (typep dref `(member ,dref)))
        => T
        (let ((dref (dref nil 'type)))
          (dtypep dref `(member ,dref)))
        => NIL
        ```
    
    - If OBJECT is not of type XREF (including DREFs) and DTYPE is a
      valid Lisp type specifier, then DTYPEP is equivalent to
      TYPEP:
    
        ```common-lisp
        (defparameter *c* (find-class 'number))
        (defparameter *m* (find-method #'dref* () '(t t t)))
        (typep *c* 'class)
        => T
        (dtypep *c* 'class)
        => T
        (typep *m* 'method)
        => T
        (dtypep *m* 'method)
        => T
        (typep 4 '(integer 3 5))
        => T
        (dtypep 4 '(integer 3 5))
        => T
        ```
    
    - DTYPE may be a @LOCATIVE-TYPE:
    
        ```common-lisp
        (dtypep (dref nil 'type) 'type)
        => T
        ```
    
    - DTYPE may be a full @LOCATIVE:
    
        ```common-lisp
        (typep *c* '(class))
        .. debugger invoked on SIMPLE-ERROR:
        ..   unknown type specifier: (CLASS)
        (dtypep *c* '(class))
        => T
        (dtypep *c* '(class junk))
        .. debugger invoked on SIMPLE-ERROR:
        ..   Bad arguments (JUNK) for locative CLASS with lambda list NIL.
        (typep *m* '(method () (t t t)))
        .. debugger invoked on SIMPLE-ERROR:
        ..   unknown type specifier: (METHOD NIL (T T T))
        (dtypep *m* '(method () (t t t)))
        => T
        ```
    
        If a full locative matches, then its locative type (without the
        locative args) also does.
    
    - DTYPE may be named by DEFINE-DTYPE:
    
        ```common-lisp
        (dtypep 7 'top)
        => T
        ```
    
    - DTYPE may be constructed with AND, OR and
      NOT from Lisp types, locative types, full locatives and
      named DTYPEs:
    
        ```common-lisp
        (typep 7 '(or type string))
        .. debugger invoked on SIMPLE-ERROR:
        ..   unknown type specifier: TYPE
        (dtypep 7 '(or type string))
        => NIL
        (dtypep 7 '(or integer type))
        => T
        (dtypep *c* '(or condition class))
        => T
        (dtypep (dref 'locate-error 'condition) '(or condition class))
        => T
        (dtypep (dref nil 'type) '(and type (not class)))
        => T
        ```


## Listing Definitions

- [function] DEFINITIONS NAME &KEY (DTYPE T)

    List all definitions of NAME that are of DTYPE as DREFs.
    
    Just as `(DREF NAME LOCATIVE)` returns the canonical definition, the
    DREF-NAMEs of returned by DEFINITIONS are different from NAME:
    
    ```common-lisp
    (definitions "PAX")
    ==> (#<DREF "MGL-PAX" PACKAGE>)
    ```
    
    ```common-lisp
    (definitions 'mgl-pax)
    ==> (#<DREF "mgl-pax" ASDF/SYSTEM:SYSTEM> #<DREF "MGL-PAX" PACKAGE>)
    ```
    
    Similarly, DREF-LOCATIVE-TYPE may be more made more specific:
    
    ```common-lisp
    (definitions 'dref:locate-error :dtype 'class)
    ==> (#<DREF LOCATE-ERROR CONDITION>)
    ```
    
    Can be extended via MAP-DEFINITIONS-OF-NAME.

- [function] DREF-APROPOS NAME &KEY PACKAGE EXTERNAL-ONLY CASE-SENSITIVE (DTYPE T)

    Return a list of DREFs corresponding to existing
    definitions that match the various arguments. First, `(DREF-APROPOS
    NIL)` lists all definitions in the running Lisp and maybe more (e.g.
    MGL-PAX:CLHS). Arguments specify how the list of
    definitions is filtered.
    
    DREF-APROPOS itself is similar to CL:APROPOS-LIST, but
    
    - it finds @DEFINITIONs not SYMBOLs,
    
    - it supports an extensible definition types, and
    
    - filtering based on them.
    
    PAX has a live browsing frontend.
    
    Roughly speaking, when NAME or PACKAGE is a SYMBOL, they must match
    the whole @NAME of the definition:
    
    ```common-lisp
    (dref-apropos 'method :package :dref :external-only t)
    ==> (#<DREF METHOD CLASS> #<DREF METHOD LOCATIVE>)
    ```
    
    On the other hand, when NAME or PACKAGE is a STRING, they are
    matched as substrings:
    
    ```common-lisp
    (dref-apropos "method" :package :dref :external-only t)
    ==> (#<DREF METHOD CLASS> #<DREF METHOD LOCATIVE>
    -->  #<DREF METHOD-COMBINATION CLASS> #<DREF METHOD-COMBINATION LOCATIVE>)
    ```
    
    Definitions that are not of DTYPE (see DTYPEP) are filtered out:
    
    ```common-lisp
    (dref-apropos "method" :package :dref :external-only t :dtype 'class)
    ==> (#<DREF METHOD CLASS> #<DREF METHOD-COMBINATION CLASS>)
    ```
    
    When PACKAGE is :NONE, only non-symbol @NAMES are matched:
    
    ```
    (dref-apropos "dref" :package :none)
    ==> (#<DREF "DREF" PACKAGE> #<DREF "DREF-EXT" PACKAGE>
    -->  #<DREF "DREF-TEST" PACKAGE> #<DREF "dref" ASDF/SYSTEM:SYSTEM>
    -->  #<DREF "dref/full" ASDF/SYSTEM:SYSTEM>
    -->  #<DREF "dref/test" ASDF/SYSTEM:SYSTEM>
    -->  #<DREF "dref/test-autoload" ASDF/SYSTEM:SYSTEM>)
    ```
    
    The exact rules of filtering are as follows. Let `C` be the @NAME of
    the candidate definition from the list of all definitions that we
    are matching against the arguments and denote its string
    representation `(PRINC-TO-STRING C)` with `P`. Note that
    PRINC-TO-STRING does not print the package of symbols. We say that
    two strings *match* if CASE-SENSITIVE is NIL and they are EQUALP, or
    CASE-SENSITIVE is true and they are EQUAL. CASE-SENSITIVE affects
    *substring* comparisons too.
    
    - If NAME is a SYMBOL, then its SYMBOL-NAME must *match* `P`.
    
    - If NAME is a STRING, then it must be a *substring* of `P`.
    
    - If PACKAGE is :ANY, then `C` must be a SYMBOL.
    
    - If PACKAGE is :NONE, then `C` must *not* be a SYMBOL.
    
    - If PACKAGE is not NIL, :ANY or :NONE, then `C` must be a symbol.
    
    - If PACKAGE is a PACKAGE, it must be EQ to the
      SYMBOL-PACKAGE of `C`.
    
    - If PACKAGE is a SYMBOL other than NIL, :ANY and :NONE, then its
      SYMBOL-NAME must *match* the PACKAGE-NAME or one of the
      PACKAGE-NICKNAMES of SYMBOL-PACKAGE of `C`.
    
    - If PACKAGE is a STRING, then it must be a *substring* of the
      PACKAGE-NAME of SYMBOL-PACKAGE of `C`.
    
    - If EXTERNAL-ONLY and `C` is a symbol, then `C` must be external in
      a matching package.
    
    - DTYPE matches candidate definition `D` if `(DTYPEP D DTYPE)`.
    
    Can be extended via MAP-REFERENCES-OF-TYPE and
    MAP-DEFINITIONS-OF-NAME.

- [function] LOCATIVE-TYPES

    Return a list of non-alias locative types.
    This is the UNION of LISP-LOCATIVE-TYPES and PSEUDO-LOCATIVE-TYPES,
    which is the set of constituents of the DTYPE TOP.

- [function] LISP-LOCATIVE-TYPES

    Return the locative types that correspond to Lisp definitions,
    which typically have SOURCE-LOCATION. These are defined with
    DEFINE-LOCATIVE-TYPE and are the constituents of DTYPE T.

- [function] PSEUDO-LOCATIVE-TYPES

    Return the locative types that correspond to non-Lisp definitions.
    These are the ones defined with DEFINE-PSEUDO-LOCATIVE-TYPE and are
    the constituents of DTYPE PSEUDO.

- [function] LOCATIVE-ALIASES

    Return the list of locatives aliases, defined with DEFINE-LOCATIVE-ALIAS.

## Operations

The following functions take a single object definition as their argument.
They may try to LOCATE the definition of the object, which may
signal a LOCATE-ERROR condition.

- [function] ARGLIST OBJECT

    Return the arglist of the definition of OBJECT or NIL if the
    arglist cannot be determined.
    
    The second return value indicates whether the arglist has been
    found. Furthermore, :ORDINARY indicates an ordinary lambda
    list, :MACRO a macro lambda list, :DEFTYPE a deftype
    lambda list, and :DESTRUCTURING a destructuring lambda
    list. Other non-NIL values are also allowed.
    
    ```common-lisp
    (arglist #'arglist)
    => (OBJECT)
    => :ORDINARY
    ```
    
    ```common-lisp
    (arglist (dref 'define-locative-type 'macro))
    => (LOCATIVE-TYPE LAMBDA-LIST &BODY DOCSTRING)
    => :MACRO
    ```
    
    ```common-lisp
    (arglist (dref 'method 'locative))
    => (METHOD-QUALIFIERS METHOD-SPECIALIZERS)
    => :DESTRUCTURING
    ```
    
    This function supports MACROs,
    COMPILER-MACROs, SETF functions,
    FUNCTIONs, GENERIC-FUNCTIONs,
    METHODs, TYPEs, LOCATIVEs. Note
    that ARGLIST depends on the quality of SWANK-BACKEND:ARGLIST. With
    the exception of SBCL, which has perfect support, all Lisp
    implementations have minor omissions:
    
    - DEFTYPE lambda lists on ABCL, AllegroCL, CLISP, CCL, CMUCL, ECL;
    
    - default values in MACRO lambda lists on AllegroCL; various edge
    
    - cases involving traced functions.
    
    Can be extended via ARGLIST\*

- [function] DOCSTRING OBJECT

    Return the docstring from the definition of OBJECT.
    As the second value, return the *PACKAGE* that was in effect when
    the docstring was installed or NIL if it cannot be determined (this
    is used by PAX:DOCUMENT when PAX::@PARSING the docstring). This
    function is similar in purpose to CL:DOCUMENTATION.
    
    Note that some locative types such as ASDF:SYSTEMS and
    DECLARATIONs have no docstrings, and some Lisp
    implementations do not record all docstrings. The following are
    known to be missing:
    
    - COMPILER-MACRO docstrings on ABCL, AllegroCL, CCL, ECL;
    
    - METHOD-COMBINATION docstrings on ABCL, AllegroCL.
    
    Can be extended via DOCSTRING\*.

- [function] SOURCE-LOCATION OBJECT &KEY ERRORP

    Return the Swank source location for the defining form
    of OBJECT. If no source location was found, then either an ERROR
    condition is signalled if ERRORP else the ERROR is
    returned as the second value (with the first being NIL). The
    returned Swank location object is to be accessed only through the
    DREF-EXT::@SOURCE-LOCATIONS API or to be passed to e.g Slime's
    `slime-goto-source-location`.
    
    Note that the availability of source location information varies
    greatly across Lisp implementations.
    
    Can be extended via SOURCE-LOCATION\*.

## Locative Types

The following are the @LOCATIVE-TYPEs supported out of the
box. As all locative types, they are named by symbols. When there is
a CL type corresponding to the reference's locative type, the
references can be RESOLVEd to a unique object as is the case in

```common-lisp
(resolve (dref 'print 'function))
==> #<FUNCTION PRINT>
```

Even if there is no such CL type, the ARGLIST, the DOCSTRING, and
the SOURCE-LOCATION of the defining form is usually recorded unless
otherwise noted.

### Locatives for Variables

- [locative] VARIABLE &OPTIONAL INITFORM
    - Direct sub locative types: [CONSTANT][c819], [SECTION][672f], [GLOSSARY-TERM][5119]

    Refers to a global special variable.
    INITFORM, or if not specified, the global value of the variable is
    to be used for @PRESENTATION.
    
    ```common-lisp
    (dref '*print-length* 'variable)
    ==> #<DREF *PRINT-LENGTH* VARIABLE>
    ```
    
    VARIABLE references do not RESOLVE.

- [locative] CONSTANT &OPTIONAL INITFORM
    - Direct super locative types: [VARIABLE][6c83]

    Refers to a constant variable defined with DEFCONSTANT. INITFORM,
    or if not specified, the value of the constant is included in the
    documentation. The CONSTANT locative is like the VARIABLE locative,
    but it also checks that its object is CONSTANTP.
    
    CONSTANT references do not RESOLVE.

### Locatives for Macros

- [locative] MACRO

    Refers to a global macro, typically defined with DEFMACRO, or to a
    special operator.
    
    MACRO references do not RESOLVE.

- [locative] SYMBOL-MACRO

    Refers to a global symbol macro, defined with DEFINE-SYMBOL-MACRO.
    Note that since DEFINE-SYMBOL-MACRO does not support docstrings, PAX
    defines methods on the DOCUMENTATION generic function specialized on
    `(DOC-TYPE (EQL 'SYMBOL-MACRO))`.
    
    ```
    (define-symbol-macro my-mac 42)
    (setf (documentation 'my-mac 'symbol-macro)
          "This is MY-MAC.")
    (documentation 'my-mac 'symbol-macro)
    => "This is MY-MAC."
    ```
    
    SYMBOL-MACRO references do not RESOLVE.

- [locative] COMPILER-MACRO

    Refers to a compiler macro, typically defined with
    DEFINE-COMPILER-MACRO.
    
    COMPILER-MACRO references do not RESOLVE.

- [locative] SETF &OPTIONAL METHOD
    - Direct super locative types: [FUNCTION][ba62]

    Refers to a setf expander (see DEFSETF and DEFINE-SETF-EXPANDER)
    or a setf function (e.g. `(DEFUN (SETF NAME) ...)` or the
    same with DEFGENERIC). The format in DEFSECTION is `(<NAME> SETF)`
    in all these cases.
    
    To refer to methods of a setf generic function, use a METHOD
    locative inside SETF like this:
    
        (dref 'documentation '(setf (method () (t symbol (eql function))))
    
    References to setf functions RESOLVE to the function object. Setf
    expander references do not RESOLVE.

### Locatives for Functions and Methods

- [locative] FUNCTION
    - Equivalent class: [FUNCTION][119e]
    
    - Direct sub locative types: [SETF][d83a], [GENERIC-FUNCTION][5875], [STRUCTURE-ACCESSOR][090c]

    Refers to a global function, typically defined with DEFUN. The
    @NAME must be a SYMBOL (see the SETF locative for how to reference
    setf functions). It is also allowed to reference
    GENERIC-FUNCTIONs as FUNCTIONs:
    
    ```common-lisp
    (dref 'docstring 'function)
    ==> #<DREF DOCSTRING FUNCTION>
    ```


- [locative] GENERIC-FUNCTION
    - Equivalent class: [GENERIC-FUNCTION][efe2]
    
    - Direct super locative types: [FUNCTION][ba62]

    Refers to a GENERIC-FUNCTION, typically defined with
    DEFGENERIC. The @NAME must be a SYMBOL (see the SETF locative for
    how to reference setf functions).

- [locative] METHOD METHOD-QUALIFIERS METHOD-SPECIALIZERS
    - Equivalent class: [METHOD][51c3]
    
    - Direct sub locative types: [READER][cc04], [WRITER][e548]

    Refers to METHODs named by SYMBOLs (for SETF methods,
    see the SETF locative). METHOD-QUALIFIERS and METHOD-SPECIALIZERS
    are similar to the CL:FIND-METHOD's arguments of the same names. For
    example, the method
    
    ```common-lisp
    (defgeneric foo-gf (x y z)
      (:method :around (x (y (eql 'xxx)) (z string))
        (values x y z)))
    ```
    
    can be referred to as
    
    ```common-lisp
    (dref 'foo-gf '(method (:around) (t (eql xxx) string)))
    ==> #<DREF FOO-GF (METHOD (:AROUND) (T (EQL XXX) STRING))>
    ```
    
    METHOD is not EXPORTABLE-LOCATIVE-TYPE-P.

- [locative] METHOD-COMBINATION
    - Equivalent class: [METHOD-COMBINATION][9b70]

    Refers to a METHOD-COMBINATION, defined with
    DEFINE-METHOD-COMBINATION.
    
    METHOD-COMBINATION references do not RESOLVE.

- [locative] ACCESSOR CLASS-NAME
    - Direct super locative types: [READER][cc04], [WRITER][e548]

    Refers to an :ACCESSOR in a DEFCLASS:
    
    ```common-lisp
    (defclass foo ()
      ((xxx :accessor foo-xxx)))
    
    (dref 'foo-xxx '(accessor foo))
    ==> #<DREF FOO-XXX (ACCESSOR FOO)>
    ```
    
    An :ACCESSOR in DEFCLASS creates a reader and a writer method.
    Somewhat arbitrarily, ACCESSOR references RESOLVE to the writer
    method but can be LOCATEd with either.

- [locative] READER CLASS-NAME
    - Direct super locative types: [METHOD][172e]
    
    - Direct sub locative types: [ACCESSOR][00d4]

    Like ACCESSOR, but refers to a :READER method in a DEFCLASS.

- [locative] WRITER CLASS-NAME
    - Direct super locative types: [METHOD][172e]
    
    - Direct sub locative types: [ACCESSOR][00d4]

    Like ACCESSOR, but refers to a :WRITER method in a DEFCLASS.

- [locative] STRUCTURE-ACCESSOR &OPTIONAL STRUCTURE-CLASS-NAME
    - Direct super locative types: [FUNCTION][ba62]

    Refers to an accessor function generated by DEFSTRUCT.
    A LOCATE-ERROR condition is signalled if the wrong
    STRUCTURE-CLASS-NAME is provided.
    
    Note that there is no portable way to detect structure accessors,
    and on some platforms, `(LOCATE #'MY-ACCESSOR)`, DEFINITIONS and
    DREF-APROPOS will return FUNCTION references instead. On such
    platforms, STRUCTURE-ACCESSOR references do not RESOLVE.

### Locatives for Types and Declarations

- [locative] TYPE
    - Direct sub locative types: [CLASS][2060], [CONDITION][c479]

    This locative can refer to types and classes and
    conditions, simply put, to things defined by DEFTYPE,
    DEFCLASS and DEFINE-CONDITION.
    
    ```common-lisp
    (deftype my-type () t)
    (dref 'my-type 'type)
    ==> #<DREF MY-TYPE TYPE>
    ```
    
    ```common-lisp
    (dref 'xref 'type)
    ==> #<DREF XREF CLASS>
    ```
    
    ```common-lisp
    (dref 'locate-error 'type)
    ==> #<DREF LOCATE-ERROR CONDITION>
    ```
    
    TYPE references do not RESOLVE.

- [locative] CLASS
    - Equivalent class: [CLASS][1f37]
    
    - Direct super locative types: [TYPE][926d]

    Naturally, CLASS is the locative type for CLASSes.
    
    Also, see the related CONDITION locative.

- [locative] DECLARATION

    Refers to a declaration, used in DECLARE, DECLAIM and PROCLAIM.
    
    User code may also define new declarations with CLTL2 functionality,
    but there is currently no way to provide a docstring, and their
    ARGLIST is always NIL.
    
    ```
    (cl-environments:define-declaration my-decl (&rest things)
      (values :declare (cons 'foo things)))
    ```
    
    DECLARATION references do not RESOLVE.
    
    Also, SOURCE-LOCATION on declarations currently only works on SBCL.

### Locatives for the Condition System

- [locative] CONDITION
    - Equivalent class: [CONDITION][83e1]
    
    - Direct super locative types: [TYPE][926d]

    Although CONDITION is not SUBTYPEP of CLASS, actual condition
    objects are commonly instances of a condition class that is a CLOS
    class. HyperSpec ISSUE:CLOS-CONDITIONS and
    ISSUE:CLOS-CONDITIONS-AGAIN provide the relevant history.
    
    Whenever a CLASS denotes a CONDITION, its DREF-LOCATIVE-TYPE will be
    CONDITION:
    
    ```common-lisp
    (dref 'locate-error 'class)
    ==> #<DREF LOCATE-ERROR CONDITION>
    ```


- [locative] RESTART
    - Equivalent class: [RESTART][38e4]

    A locative to refer to the definition of a restart defined by
    DEFINE-RESTART.

- [macro] DEFINE-RESTART SYMBOL LAMBDA-LIST &BODY DOCSTRING

    Associate a definition with the name of a restart, which must be a symbol.
    LAMBDA-LIST should be what calls like `(INVOKE-RESTART '<SYMBOL>
    ...)` must conform to, but this not enforced.
    
    PAX "defines" standard CL restarts such as USE-VALUE with
    DEFINE-RESTART:
    
    ```common-lisp
    (first-line (source-location-snippet
                 (source-location (dref 'use-value 'restart))))
    => "(define-restart use-value (value)"
    ```
    
    Note that while there is a CL:RESTART class, its instances have no
    docstring or source location.

### Locatives for Packages and Readtables

- [locative] ASDF/SYSTEM:SYSTEM
    - Equivalent class: ASDF/SYSTEM:SYSTEM

    Refers to an already loaded ASDF:SYSTEM (those in ASDF:REGISTERED-SYSTEMS).
    The @NAME may be anything ASDF:FIND-SYSTEM supports.
    
    ASDF:SYSTEM is not EXPORTABLE-LOCATIVE-TYPE-P.

- [locative] PACKAGE
    - Equivalent class: [PACKAGE][1d5a]

    Refers to a PACKAGE, defined by DEFPACKAGE or MAKE-PACKAGE.
    The @NAME may be anything FIND-PACKAGE supports.
    
    PACKAGE is not EXPORTABLE-LOCATIVE-TYPE-P.

- [locative] READTABLE
    - Equivalent class: [READTABLE][d646]

    Refers to a named READTABLE defined with
    NAMED-READTABLES:DEFREADTABLE, which associates a global name and a
    docstring with the readtable object. The @NAME may be anything
    FIND-READTABLE supports. Unfortunately, SOURCE-LOCATION information
    is not available.
    
    READTABLE references RESOLVE to FIND-READTABLE on their @NAME.

### DRef Locatives

- [locative] LOCATIVE
    - Direct super locative types: [DTYPE][85ba]

    This is the locative for @LOCATIVE-TYPEs defined with
    DEFINE-LOCATIVE-TYPE, DEFINE-PSEUDO-LOCATIVE-TYPE and
    DEFINE-LOCATIVE-ALIAS.
    
    ```
    (first-line (source-location-snippet
                 (source-location (dref 'macro 'locative))))
    => "(define-locative-type macro ()"
    ```


- [locative] DTYPE
    - Direct sub locative types: [LOCATIVE][0b3a]

    Locative for @DTYPES defined with DEFINE-DTYPE and LOCATIVE types.
    DTYPE is to LOCATIVE as TYPE is to CLASS.
    
    The TOP of the DTYPE hiearchy:
    
    ```common-lisp
    (dref 'top 'dtype)
    ==> #<DREF TOP DTYPE>
    ```
    
    This very definition:
    
    ```common-lisp
    (dref 'dtype 'locative)
    ==> #<DREF DTYPE LOCATIVE>
    ```


- [locative] UNKNOWN DSPEC

    This locative type allows PAX to work in a limited way with
    locatives it doesn't know. UNKNOWN definitions come from
    DEFINITIONS, which uses SWANK/BACKEND:FIND-DEFINITIONS. The
    following examples show PAX stuffing the Swank
    dspec `(:DEFINE-ALIEN-TYPE DOUBLE-FLOAT)` into an UNKNOWN locative
    on SBCL.
    
    ```common-lisp
    (definitions 'double-float)
    ==> (#<DREF DOUBLE-FLOAT CLASS>
    -->  #<DREF DOUBLE-FLOAT (UNKNOWN (:DEFINE-ALIEN-TYPE DOUBLE-FLOAT))>)
    ```
    
    ```common-lisp
    (dref 'double-float '(unknown (:define-alien-type double-float)))
    ==> #<DREF DOUBLE-FLOAT (UNKNOWN (:DEFINE-ALIEN-TYPE DOUBLE-FLOAT))>
    ```
    
    ARGLIST and DOCSTRING return NIL for UNKNOWNs, but SOURCE-LOCATION
    works.

- [locative] LAMBDA &KEY ARGLIST ARGLIST-TYPE DOCSTRING DOCSTRING-PACKAGE FILE FILE-POSITION SNIPPET &ALLOW-OTHER-KEYS

    A pseudo locative type that carries its
    ARGLIST, DOCSTRING and SOURCE-LOCATION in the locative itself. See
    MAKE-SOURCE-LOCATION for the description of FILE, FILE-POSITION, and
    SNIPPET. LAMBDA references do not RESOLVE. The @NAME must be NIL.
    
    ```common-lisp
    (arglist (dref nil '(lambda :arglist ((x y) z)
                                :arglist-type :macro)))
    => ((X Y) Z)
    => :MACRO
    ```
    
    ```common-lisp
    (docstring (dref nil '(lambda :docstring "xxx"
                                  :docstring-package :dref)))
    => "xxx"
    ==> #<PACKAGE "DREF">
    ```
    
    ```common-lisp
    (source-location-file
     (source-location (dref nil '(lambda :file "xxx.el"))))
    => "xxx.el"
    ```
    
    Also, see the PAX:INCLUDE locative.

## Glossary

- [glossary-term] name

    Names are symbols or strings which name functions, types, packages,
    etc. Together with @LOCATIVEs, they form @REFERENCEs.
    
    See XREF-NAME and DREF-NAME.

- [glossary-term] locative

    Locatives specify a *type* of definition such as
    FUNCTION or VARIABLE and together with
    @NAMEs form @REFERENCEs.
    
    A locative can be a symbol or a list whose CAR is a symbol. In
    either case, the symbol is called the @LOCATIVE-TYPE, and the rest
    of the elements are the *locative arguments* (for example, see the
    METHOD locative).
    
    See XREF-LOCATIVE and DREF-LOCATIVE.

- [glossary-term] locative type

    The locative type is the part of a @LOCATIVE that identifies
    what kind definition is being referred to. See @LOCATIVE-TYPES for
    the list locative types built into DRef, and MGL-PAX::@PAX-LOCATIVES
    for those in PAX.
    
    See XREF-LOCATIVE-TYPE, DREF-LOCATIVE-TYPE and EXPAND-DTYPE, that
    expands the compound @DTYPES to a list of locative types.

- [glossary-term] reference

    A reference is a @NAME plus a @LOCATIVE, and it identifies a
    possible definition. References are of class XREF. When a reference
    is a DREF, it may also be called a definition.

- [glossary-term] definition

    A definition is a @REFERENCE that identifies a concrete definition.
    Definitions are of class DREF. A definition RESOLVEs to the
    first-class object associated with the definition if such a thing
    exists, and LOCATE on this object returns a DREF object that's
    unique under XREF=.
    
    The kind of a definition is given by its @LOCATIVE-TYPE.

- [glossary-term] presentation

    @REFERENCEs may have arguments (see
    DREF-EXT::@ADDING-NEW-LOCATIVES) that do not affect the behaviour of
    LOCATE and the standard DRef @OPERATIONS, but which may be used for
    other, "presentation" purposes. For example, the VARIABLE
    locative's INITFORM argument is used for presentation by
    PAX:DOCUMENT. Presentation arguments are available via
    DREF-EXT:DREF-ORIGIN.

## Extending DRef

### References

- [reader] XREF-NAME [XREF][1538] (:NAME)

    The @NAME of the reference.

- [reader] XREF-LOCATIVE [XREF][1538] (:LOCATIVE)

    The @LOCATIVE of the reference.
    
    The locative is normalized by replacing single-element lists with
     their only element:
    
    ```common-lisp
    (xref 'print 'function)
    ==> #<XREF PRINT FUNCTION>
    ```
    
    ```common-lisp
    (xref 'print '(function))
    ==> #<XREF PRINT FUNCTION>
    ```


- [reader] DREF-NAME [DREF][d930]

    The same as XREF-NAME, but only works on
    DREFs. Use it as a statement of intent.

- [reader] DREF-LOCATIVE [DREF][d930]

    The same as XREF-LOCATIVE, but only works on
    DREFs. Use it as a statement of intent.

- [reader] DREF-ORIGIN [DREF][d930]

    The object from which LOCATE constructed this
    DREF. This is an XREF when the LOCATIVE argument
    to LOCATE was non-NIL and the value NAME-OR-OBJECT argument
    otherwise. DREF-ORIGIN may have @PRESENTATION arguments, which are
    not included in LOCATIVE-ARGS as is the case with INITFORM
    argument of the VARIABLE locative:
    
    ```common-lisp
    (dref '*standard-output* '(variable "see-below"))
    ==> #<DREF *STANDARD-OUTPUT* VARIABLE>
    ```
    
    ```common-lisp
    (dref-origin (dref '*standard-output* '(variable "see-below")))
    ==> #<XREF *STANDARD-OUTPUT* (VARIABLE "see-below")>
    ```
    
    The INITFORM argument overrides the global binding of
    *STANDARD-OUTPUT* when it's PAX:DOCUMENTed:
    
    ```common-lisp
    (first-line
     (pax:document (dref '*standard-output* '(variable "see-below"))
                   :stream nil))
    => "- [variable] *STANDARD-OUTPUT* \"see-below\""
    ```


- [function] LOCATIVE-TYPE LOCATIVE

    Return @LOCATIVE-TYPE of LOCATIVE (which may be from
    XREF-LOCATIVE). This is the first element of LOCATIVE if it's a
    list. If it's a symbol, it's that symbol itself.

- [function] LOCATIVE-ARGS LOCATIVE

    Return the REST of LOCATIVE (which may be from XREF-LOCATIVE)
    if it's a list. If it's a symbol, then return NIL. The locative args
    should match the LAMBDA-LIST of the LOCATIVE-TYPE's
    definition, but this is guaranteed only for
    locatives of DREFs and is not checked for plain
    XREFs.

The following convenience functions are compositions of
{`LOCATIVE-TYPE`, `LOCATIVE-ARGS`} and {`XREF-LOCATIVE`,
`DREF-LOCATIVE`}.

- [function] XREF-LOCATIVE-TYPE XREF

- [function] XREF-LOCATIVE-ARGS XREF

- [function] DREF-LOCATIVE-TYPE DREF

- [function] DREF-LOCATIVE-ARGS DREF

### Adding New Locatives

Let's see how to tell DRef about new kinds of definitions through
the example of the implementation of the CLASS locative. Note that
this is a verbatim PAX:INCLUDE of the sources. Please
ignore any internal machinery. The first step is to define the
locative type:

```
(define-locative-type class ()
  "Naturally, CLASS is the locative type for [CLASS][class]es.

  Also, see the related CONDITION locative.")

```

Next, we define a subclass of DREF associated with the
CLASS locative type and specialize LOCATE\*:

```
(define-definition-class class class-dref (type-dref))

(defmethod locate* ((class class))
  (make-instance 'class-dref :name (class-name class) :locative 'class))

(defmethod dref* (symbol (locative-type (eql 'class)) locative-args)
  (check-locative-args class locative-args)
  (unless (and (symbolp symbol)
               (find-class symbol nil))
    (locate-error "~S does not name a class." symbol))
  (make-instance 'class-dref :name symbol :locative 'class))

```

The first method makes `(LOCATE (FIND-CLASS 'DREF))` work, while
the second is for `(DREF 'DREF 'CLASS)`. Naturally, for locative
types that do not define first-class objects, the first method
cannot be defined.

Then, with ADD-DREF-ACTUALIZER, we install a function that that runs
whenever a new DREF is about to be returned from LOCATE and
turn the locative TYPE into the locative CLASS if the denoted
definition is of a class:

```
(defun actualize-type-to-class (dref)
  (when (eq (dref-locative-type dref) 'type)
    (dref (dref-name dref) 'class nil)))

(add-dref-actualizer 'actualize-type-to-class)

```

Finally, we define a RESOLVE\* method to recover the
CLASS object from a CLASS-DREF. We also specialize
DOCSTRING\* and SOURCE-LOCATION\*:

```
(defmethod resolve* ((dref class-dref))
  (find-class (dref-name dref)))

(defmethod docstring* ((class class))
  (documentation* class t))

(defmethod source-location* ((dref class-dref))
  (swank-source-location* (resolve dref) (dref-name dref) 'class))

```

We took advantage of having just made the class locative type being
RESOLVEable, by specializing DOCSTRING\* on the CLASS class.
SOURCE-LOCATION\* was specialized on CLASS-DREF to demonstrate how
this can be done for non-RESOLVEable locative types.

Classes have no arglist, so no ARGLIST\* method is needed. In the
following, we describe the pieces in detail.

- [macro] DEFINE-LOCATIVE-TYPE LOCATIVE-TYPE LAMBDA-LIST &BODY DOCSTRING

    Declare LOCATIVE-TYPE as a LOCATIVE, which is the
    first step in DREF-EXT::@EXTENDING-DREF.
    
    LAMBDA-LIST is a destructuring lambda list. The
    LOCATIVE-ARGS of DREFs with @LOCATIVE-TYPE
    LOCATIVE-TYPE (the argument given to this macro) always conform to
    this lambda list. See CHECK-LOCATIVE-ARGS.
    
    - If there is a CLASS named LOCATIVE-TYPE, then LOCATIVE-TYPE must
      be able to represent exactly the set of definitions of that class.
    
    - A non-class Lisp type and locative type with the same name must
      not exist at the same time.
    
    For example, if we have:
    
    ```
    (define-locative-type dummy (x &key y)
      "Dummy docstring.")
    ```
    
    then `(LOCATE 'DUMMY 'LOCATIVE)` refers to this definition. That is,
    ARGLIST, DOCSTRING and SOURCE-LOCATION all work on it.
    
    Locative types defined with DEFINE-LOCATIVE-TYPE can be listed with
    LISP-LOCATIVE-TYPES.

- [macro] DEFINE-PSEUDO-LOCATIVE-TYPE LOCATIVE-TYPE LAMBDA-LIST &BODY DOCSTRING

    Like DEFINE-LOCATIVE-TYPE, but declare that LOCATIVE-TYPE does
    not correspond to definitions in the Lisp system. Definitions with
    pseduo locatives are not listed by default by DEFINITIONS.
    
    Locative types defined with DEFINE-PSEUDO-LOCATIVE-TYPE can be
    listed with PSEUDO-LOCATIVE-TYPES.

- [macro] DEFINE-LOCATIVE-ALIAS ALIAS LOCATIVE-TYPE &BODY DOCSTRING

    Define ALIAS that can be substituted for LOCATIVE-TYPE (both
    SYMBOLs) for the purposes of LOCATEing. LOCATIVE-TYPE must
    exist (i.e. be among LOCATIVE-TYPES). For example, let's define
    OBJECT as an alias of the CLASS locative:
    
    ```common-lisp
    (define-locative-alias object class)
    ```
    
    Then, LOCATEing with OBJECT will find the CLASS:
    
    ```common-lisp
    (dref 'xref 'object)
    ==> #<DREF XREF CLASS>
    ```
    
    The LOCATIVE-ARGS of OBJECT (none in the above) are passed on to
    CLASS.
    
    ```common-lisp
    (arglist (dref 'object 'locative))
    => (&REST ARGS)
    => :DESTRUCTURING
    ```
    
    Note that LOCATIVE-ALIASES are not LOCATIVE-TYPES and are not valid
    DTYPES.
    
    Also, see PAX::@LOCATIVE-ALIASES in PAX.

- [macro] DEFINE-DEFINITION-CLASS LOCATIVE-TYPE CLASS-NAME &OPTIONAL (SUPERCLASSES '(DREF)) &BODY BODY

    Define a subclass of DREF with CLASS-NAME. All @DEFINITIONs with
    LOCATEable with a @LOCATIVE of LOCATIVE-TYPE must be of the type
    named by CLASS-NAME. If non-NIL, BODY is DEFCLASS's slot definitions
    and other options.
    
    The hiererarchy of definition classes as defined by SUPERCLASSES
    must agree with the hierarchy of the classes named by
    @LOCATIVE-TYPEs. That is, if two locative types `L1` and `L2` with
    definition classes `D1` and `D2` both name CLASSes, then it must be
    that (SUBTYPEP D1 D2) iff (SUBTYPEP L1 L2).
    
    Also, definition classes of LISP-LOCATIVE-TYPES and
    PSEUDO-LOCATIVE-TYPES must not intersect.

- [generic-function] LOCATE* OBJECT

    Return a definition of OBJECT as a DREF,
    without actualizing it. If OBJECT is a DREF
    already, then this function simply returns it. If no definition is
    found for OBJECT, then LOCATE-ERROR is signalled.
    
    This function is for extending LOCATE. Do not call it directly.

- [generic-function] DREF* NAME LOCATIVE-TYPE LOCATIVE-ARGS

    LOCATE\* calls this for XREFs which are not
    DREFs.
    
    An EQL-specialized method must be defined for all new locative
    types. This function is for extending LOCATE. Do not call it
    directly.

- [macro] CHECK-LOCATIVE-ARGS LOCATIVE-TYPE LOCATIVE-ARGS

    Signal a LOCATE-ERROR condition if LOCATIVE-ARGS do not match the
    LAMBDA-LIST argument of LOCATIVE-TYPE (not evaluated).

- [function] LOCATE-ERROR &OPTIONAL FORMAT-CONTROL &REST FORMAT-ARGS

    Call this function to signal a LOCATE-ERROR condition from the
    dynamic extent of a LOCATE\* method (which includes
    DREF\*). It is an error to call LOCATE-ERROR elsewhere.
    
    FORMAT-CONTROL, if non-NIL, is a format control for which
    FORMAT-ARGS are suitable.

- [function] ADD-DREF-ACTUALIZER NAME

    Add the global function denoted by the symbol NAME to the list
    of actualizers. Actualizers are functions of a single DREF
    argument. They are called within LOCATE when LOCATE\* returns a DREF.
    Their job is to make the DREF more specific.

- [function] REMOVE-DREF-ACTUALIZER NAME

    Remove the global function denoted by the symbol NAME from the
    list of actualizers.

- [generic-function] RESOLVE* DREF

    Return the object defined by the definition DREF
    refers to. Signal a RESOLVE-ERROR condition by calling the
    RESOLVE-ERROR function if the lookup fails.
    
    To keep RESOLVE a partial inverse of LOCATE, a specialized LOCATE\*
    method or an actualizer must be defined for
    RESOLVEable definitions. This function is for extending RESOLVE. Do
    not call it directly.
    
    It is an error for methods of this generic function to return an
    XREF.

- [function] RESOLVE-ERROR &REST FORMAT-AND-ARGS

    Call this function to signal a RESOLVE-ERROR condition from the
    dynamic extent of a RESOLVE\* method. It is an error to call
    RESOLVE-ERROR elsewhere.
    
    FORMAT-AND-ARGS, if non-NIL, is a format string and arguments
    suitable for FORMAT.

- [generic-function] MAP-DEFINITIONS-OF-NAME FN NAME LOCATIVE-TYPE

    Call FN with DREFs which can be LOCATEd
    with an XREF with NAME, LOCATIVE-TYPE and some LOCATIVE-ARGS. The
    strange wording here is because there may be multiple ways (and thus
    XREFs) that refer to the same definition.
    
    For most locative types, there is at most one such definition, but
    for METHOD, for example, there may be many. The default method
    simply does `(DREF NAME LOCATIVE-TYPE NIL)` and calls FN with result
    if DREF succeeds.
    
    FN must not be called with the same (under XREF=) definition
    multiple times.
    
    This function is for extending DEFINITIONS and DREF-APROPOS. Do not
    call it directly.

- [generic-function] MAP-DEFINITIONS-OF-TYPE FN LOCATIVE-TYPE

    Call FN with DREFs which can be LOCATEd
    with an XREF with LOCATIVE-TYPE with some NAME and LOCATIVE-ARGS.
    
    The default method forms XREFs by combining each interned symbol as
    @NAMEs with LOCATIVE-TYPE and no LOCATIVE-ARGS and calls FN if it
    LOCATEs a definition.
    
    FN may be called with DREFs that are XREF= but differ in the XREF in
    their DREF-ORIGIN.
    
    This function is for extending DREF-APROPOS. Do not call it
    directly.

- [generic-function] ARGLIST* OBJECT

    To extend ARGLIST, specialize this on a subclass of
    DREF if that subclass is not RESOLVEable, else on the type
    of object it resolves to. This function is for extension only. Do
    not call it directly.

- [generic-function] DOCSTRING* DREF

    To extend DOCSTRING, specialize this on a subclass
    of DREF if that subclass is not RESOLVEable, else on the
    type of object it resolves to. This function is for extension only.
    Do not call it directly.

- [generic-function] SOURCE-LOCATION* DREF

    To extend SOURCE-LOCATION, specialize this on a
    subclass of DREF if that subclass is not RESOLVEable, else
    on the type of object it resolves to. This function is for extension
    only. Do not call it directly.

### Symbol Locatives

Let's see how the opaque DEFINE-SYMBOL-LOCATIVE-TYPE and the
obscure DEFINE-DEFINER-FOR-SYMBOL-LOCATIVE-TYPE macros work together
to simplify the common task of associating definition with a symbol
in a certain context.

- [macro] DEFINE-SYMBOL-LOCATIVE-TYPE LOCATIVE-TYPE LAMBDA-LIST &BODY DOCSTRING

    Similar to DEFINE-LOCATIVE-TYPE, but it assumes that all things
    LOCATEable with LOCATIVE-TYPE are going to be symbols defined with a
    definer defined with DEFINE-DEFINER-FOR-SYMBOL-LOCATIVE-TYPE. Symbol
    locatives are for attaching a definition (along with arglist,
    documentation and source location) to a symbol in a particular
    context. An example will make everything clear:
    
    ```
    (define-symbol-locative-type direction ()
      "A direction is a symbol.")
    
    (define-definer-for-symbol-locative-type define-direction direction
      "With DEFINE-DIRECTION, one can document what a symbol means when
      interpreted as a DIRECTION.")
    
    (define-direction up ()
      "UP is equivalent to a coordinate delta of (0, -1).")
    ```
    
    After all this, `(DREF 'UP 'DIRECTION)` refers to the
    `DEFINE-DIRECTION` form above.

- [macro] DEFINE-DEFINER-FOR-SYMBOL-LOCATIVE-TYPE NAME LOCATIVE-TYPE &BODY DOCSTRING

    Define a macro with NAME that can be used to attach a lambda list,
    documentation, and source location to a symbol in the context of
    LOCATIVE-TYPE. The defined macro's arglist is `(SYMBOL LAMBDA-LIST
    &OPTIONAL DOCSTRING)`. LOCATIVE-TYPE is assumed to have been defined
    with DEFINE-SYMBOL-LOCATIVE-TYPE.

### DREF Subclasses

These are the DREF subclasses corresponding to
DREF::@LOCATIVE-TYPES. They are exported to make it possible to go
beyond the standard @OPERATIONS (e.g. PAX:DOCUMENT-OBJECT\*) and for
subclassing.

**for Variables**

- [class] VARIABLE-DREF DREF

- [class] CONSTANT-DREF VARIABLE-DREF

**for Macros**

- [class] MACRO-DREF DREF

- [class] SYMBOL-MACRO-DREF DREF

- [class] COMPILER-MACRO-DREF DREF

- [class] SETF-DREF FUNCTION-DREF

**for Functions**

- [class] FUNCTION-DREF DREF

- [class] GENERIC-FUNCTION-DREF FUNCTION-DREF

- [class] METHOD-DREF DREF

- [class] METHOD-COMBINATION-DREF DREF

- [class] ACCESSOR-DREF READER-DREF WRITER-DREF

- [class] READER-DREF METHOD-DREF

- [class] WRITER-DREF METHOD-DREF

- [class] STRUCTURE-ACCESSOR-DREF FUNCTION-DREF

**for Types and Declarations**

- [class] TYPE-DREF DREF

- [class] CLASS-DREF TYPE-DREF

- [class] DECLARATION-DREF DREF

**for the Condition System**

- [class] CONDITION-DREF TYPE-DREF

- [class] RESTART-DREF SYMBOL-LOCATIVE-DREF

**for Packages and Readtables**

- [class] ASDF-SYSTEM-DREF DREF

- [class] PACKAGE-DREF DREF

- [class] READTABLE-DREF DREF

**for DRef Locatives**

- [class] LOCATIVE-DREF DTYPE-DREF

- [class] DTYPE-DREF DREF

- [class] SYMBOL-LOCATIVE-DREF DREF

- [class] UNKNOWN-DREF DREF

- [class] LAMBDA-DREF DREF

### Source Locations

These represent the file or buffer position of a defining
form and are returned by the SOURCE-LOCATION function. For
the details, see the Elisp function `slime-goto-source-location`.

- [function] MAKE-SOURCE-LOCATION &KEY FILE FILE-POSITION BUFFER BUFFER-POSITION SNIPPET

    Make a Swank source location. The ultimate reference is `slime.el`.
    When SNIPPET is provided, the match nearest to FILE-POSITION is
    determined (see the Elisp `slime-isearch` and
    SOURCE-LOCATION-ADJUSTED-FILE-POSITION).

- [function] SOURCE-LOCATION-P OBJECT

    See if OBJECT is a source location object.

- [function] SOURCE-LOCATION-FILE LOCATION

    Return the name of the file of the defining form.
    This may be NIL, for example, if LOCATION is of a defining
    form that was entered at the REPL, or compiled in the
    `*slime-scratch*` buffer.

- [function] SOURCE-LOCATION-FILE-POSITION LOCATION

    Return the file position of the defining form or NIL
    if it's not available. The first position is 0.

- [function] SOURCE-LOCATION-BUFFER LOCATION

    Return the name of the Emacs buffer of the defining form or
    NIL if there is no such Emacs buffer.

- [function] SOURCE-LOCATION-BUFFER-POSITION LOCATION

    Return the position of the defining form in
    SOURCE-LOCATION-BUFFER or NIL if it's not available. The first
    position is 1.

- [function] SOURCE-LOCATION-SNIPPET LOCATION

    Return the defining form or a prefix of it as a string or NIL
    if it's not available.

- [function] SOURCE-LOCATION-ADJUSTED-FILE-POSITION LOCATION

    Return the actual file position LOCATION points to allowing for 
    some deviation from the raw SOURCE-LOCATION-FILE-POSITION, which is
    adjusted by searching for the nearest occurrence of
    SOURCE-LOCATION-SNIPPET in the file. Needless to say, this can be a
    very expensive operation.
    
    If SOURCE-LOCATION-FILE is NIL, NIL is returned. If there is no
    snippet, or it doesn't match, then SOURCE-LOCATION-FILE-POSITION (or
    0 if that's NIL) is returned.
    
    This is a non-interactive companion to the Elisp function
    `slime-location-offset`, supporting only file positions and
    non-partial matching of snippets.

  [00d4]: #x-28MGL-PAX-3AACCESSOR-20MGL-PAX-3ALOCATIVE-29 "MGL-PAX:ACCESSOR MGL-PAX:LOCATIVE"
  [090c]: #x-28MGL-PAX-3ASTRUCTURE-ACCESSOR-20MGL-PAX-3ALOCATIVE-29 "MGL-PAX:STRUCTURE-ACCESSOR MGL-PAX:LOCATIVE"
  [0b3a]: #x-28MGL-PAX-3ALOCATIVE-20MGL-PAX-3ALOCATIVE-29 "MGL-PAX:LOCATIVE MGL-PAX:LOCATIVE"
  [119e]: http://www.lispworks.com/documentation/HyperSpec/Body/t_fn.htm "FUNCTION (MGL-PAX:CLHS CLASS)"
  [1538]: #x-28DREF-3AXREF-20CLASS-29 "DREF:XREF CLASS"
  [172e]: #x-28METHOD-20MGL-PAX-3ALOCATIVE-29 "METHOD MGL-PAX:LOCATIVE"
  [1d5a]: http://www.lispworks.com/documentation/HyperSpec/Body/t_pkg.htm "PACKAGE (MGL-PAX:CLHS CLASS)"
  [1f37]: http://www.lispworks.com/documentation/HyperSpec/Body/t_class.htm "CLASS (MGL-PAX:CLHS CLASS)"
  [2060]: #x-28CLASS-20MGL-PAX-3ALOCATIVE-29 "CLASS MGL-PAX:LOCATIVE"
  [38e4]: http://www.lispworks.com/documentation/HyperSpec/Body/t_rst.htm "RESTART (MGL-PAX:CLHS CLASS)"
  [5119]: ../README#x-28MGL-PAX-3AGLOSSARY-TERM-20MGL-PAX-3ALOCATIVE-29 "MGL-PAX:GLOSSARY-TERM MGL-PAX:LOCATIVE"
  [51c3]: http://www.lispworks.com/documentation/HyperSpec/Body/t_method.htm "METHOD (MGL-PAX:CLHS CLASS)"
  [5875]: #x-28GENERIC-FUNCTION-20MGL-PAX-3ALOCATIVE-29 "GENERIC-FUNCTION MGL-PAX:LOCATIVE"
  [672f]: ../README#x-28MGL-PAX-3ASECTION-20MGL-PAX-3ALOCATIVE-29 "MGL-PAX:SECTION MGL-PAX:LOCATIVE"
  [6c83]: #x-28VARIABLE-20MGL-PAX-3ALOCATIVE-29 "VARIABLE MGL-PAX:LOCATIVE"
  [83e1]: http://www.lispworks.com/documentation/HyperSpec/Body/e_cnd.htm "CONDITION (MGL-PAX:CLHS CONDITION)"
  [85ba]: #x-28DREF-3ADTYPE-20MGL-PAX-3ALOCATIVE-29 "DREF:DTYPE MGL-PAX:LOCATIVE"
  [926d]: #x-28TYPE-20MGL-PAX-3ALOCATIVE-29 "TYPE MGL-PAX:LOCATIVE"
  [9b70]: http://www.lispworks.com/documentation/HyperSpec/Body/t_meth_1.htm "METHOD-COMBINATION (MGL-PAX:CLHS CLASS)"
  [ba62]: #x-28FUNCTION-20MGL-PAX-3ALOCATIVE-29 "FUNCTION MGL-PAX:LOCATIVE"
  [c479]: #x-28CONDITION-20MGL-PAX-3ALOCATIVE-29 "CONDITION MGL-PAX:LOCATIVE"
  [c819]: #x-28MGL-PAX-3ACONSTANT-20MGL-PAX-3ALOCATIVE-29 "MGL-PAX:CONSTANT MGL-PAX:LOCATIVE"
  [cc04]: #x-28MGL-PAX-3AREADER-20MGL-PAX-3ALOCATIVE-29 "MGL-PAX:READER MGL-PAX:LOCATIVE"
  [d646]: http://www.lispworks.com/documentation/HyperSpec/Body/t_rdtabl.htm "READTABLE (MGL-PAX:CLHS CLASS)"
  [d83a]: #x-28SETF-20MGL-PAX-3ALOCATIVE-29 "SETF MGL-PAX:LOCATIVE"
  [d930]: #x-28DREF-3ADREF-20CLASS-29 "DREF:DREF CLASS"
  [e548]: #x-28MGL-PAX-3AWRITER-20MGL-PAX-3ALOCATIVE-29 "MGL-PAX:WRITER MGL-PAX:LOCATIVE"
  [efe2]: http://www.lispworks.com/documentation/HyperSpec/Body/t_generi.htm "GENERIC-FUNCTION (MGL-PAX:CLHS CLASS)"

* * *
###### \[generated by [MGL-PAX](https://github.com/melisgl/mgl-pax)\]
